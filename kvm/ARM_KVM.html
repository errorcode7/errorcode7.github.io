<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>kvm</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-8adf115d.css">
        <link rel="stylesheet" href="../css/general-2459343d.css">
        <link rel="stylesheet" href="../css/chrome-ae938929.css">
        <link rel="stylesheet" href="../css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="../ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-56aa291c.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-3c9db5cd.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="arm-kvm上下文切换机制分析"><a class="header" href="#arm-kvm上下文切换机制分析">ARM KVM上下文切换机制分析</a></h1>
<hr>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>本文档深入分析ARM架构中KVM（Kernel-based Virtual Machine）的上下文切换机制，重点解析<code>__kvm_vcpu_run_vhe</code>函数的工作原理和上下文切换的具体实现。本文需要有一定的知识，如中断、系统调用、x86虚拟化、arm异常级别，虚拟地址翻译等。</p>
<h3 id="关键概念"><a class="header" href="#关键概念">关键概念</a></h3>
<ul>
<li><strong>VHE (Virtualization Host Extension)</strong>：ARMv8.1引入的虚拟化扩展，允许hypervisor在EL2运行</li>
<li><strong>Non-VHE</strong>：传统虚拟化模式，hypervisor在EL1，依赖EL2进行虚拟化操作</li>
<li><strong>上下文切换</strong>：在host、guest和hypervisor之间切换执行状态的过程</li>
<li><strong>阶段2转换</strong>：guest虚拟地址到物理地址的地址转换</li>
</ul>
<h3 id="寄存器分类"><a class="header" href="#寄存器分类">寄存器分类</a></h3>
<p>在了解上下文切换之前，我们必须先了解寄存器的分类。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类别</th><th>核心作用</th><th>典型场景</th><th>是否需上下文切换时保存？</th></tr>
</thead>
<tbody>
<tr><td><strong>执行上下文寄存器</strong></td><td>运行程序的“工作台”</td><td>函数调用、变量存储</td><td>✅ 必须（Host/Guest 切换）</td></tr>
<tr><td><strong>系统控制寄存器</strong></td><td>配置 CPU“工作模式”</td><td>开启MMU、设置页表、虚拟化陷阱</td><td>✅ Guest 独有，Host/Guest 切换时保存</td></tr>
<tr><td><strong>异常状态寄存器</strong></td><td>记录“出事时的情况”</td><td>缺页处理、未定义指令捕获</td><td>❌ 异常处理完即用完，不长期保存</td></tr>
</tbody>
</table>
</div>
<h4 id="执行上下文寄存器execution-context-registers"><a class="header" href="#执行上下文寄存器execution-context-registers">执行上下文寄存器（Execution Context Registers）</a></h4>
<p>作用：直接参与程序的指令执行与数据运算，是“代码运行时的现场”。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>子类</th><th>寄存器示例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>通用寄存器</td><td><code>x0–x30</code></td><td>存放操作数、地址、函数参数/返回值</td></tr>
<tr><td>程序计数器</td><td>PC（隐式）</td><td>指向下一条要执行的指令</td></tr>
<tr><td>栈指针</td><td><code>SP_EL0/1/2</code></td><td>指向当前栈顶，用于函数调用/局部变量</td></tr>
<tr><td>链接寄存器</td><td><code>x30</code> / <code>LR_ELx</code></td><td>保存函数返回地址</td></tr>
</tbody>
</table>
</div>
<ul>
<li>被编译器和 ABI 直接使用。</li>
<li>用户态和内核态都大量使用。</li>
<li>上下文切换（如进程调度、VM-Exit）时<strong>必须完整保存/恢复</strong>。</li>
</ul>
<h4 id="统控制寄存器system-control-registers"><a class="header" href="#统控制寄存器system-control-registers">统控制寄存器（System Control Registers）</a></h4>
<p>作用：配置 CPU 的行为模式，决定“如何执行”而非“执行什么”。它的核心特点是<strong>控制</strong>。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>功能域</th><th>寄存器示例</th><th>控制内容</th></tr>
</thead>
<tbody>
<tr><td>内存管理</td><td><code>SCTLR_EL1</code>, <code>TTBR0_EL1</code>, <code>TCR_EL1</code></td><td>MMU 开关、页表基址、地址空间布局</td></tr>
<tr><td>虚拟化</td><td><code>HCR_EL2</code>, <code>VTTBR_EL2</code></td><td>是否启用 Stage-2 转换、哪些操作 trap 到 EL2</td></tr>
<tr><td>中断/异常</td><td><code>DAIF</code>（PSTATE）、<code>ICC_SRE_EL1</code></td><td>屏蔽 IRQ/FIQ/SError、中断路由</td></tr>
<tr><td>安全扩展</td><td><code>SCR_EL3</code></td><td>EL2 是否可用、Secure/Non-secure 切换</td></tr>
<tr><td>性能/调试</td><td><code>PMCR_EL0</code>, <code>OSLAR_EL1</code></td><td>性能计数器使能、调试锁</td></tr>
</tbody>
</table>
</div>
<ul>
<li>通常只在特权级（EL1/EL2/EL3）可写，一般由<strong>操作系统和内核模块</strong>负责修改。</li>
<li>修改后影响后续所有指令的执行环境。</li>
<li>很多寄存器的某一位是“控制位”，另一些位是“状态位”。</li>
</ul>
<h4 id="异常与状态保存寄存器exception--state-saving-registers"><a class="header" href="#异常与状态保存寄存器exception--state-saving-registers">异常与状态保存寄存器（Exception &amp; State-Saving Registers）</a></h4>
<p>作用：在异常发生时自动保存关键状态，用于后续恢复或诊断。它们不用于主动控制 CPU，而是被动反映异常瞬间的状态，影响操作系统的执行逻辑。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>寄存器</th><th>作用</th></tr>
</thead>
<tbody>
<tr><td><code>ELR_ELx</code></td><td>保存异常发生时的 <strong>PC（返回地址）</strong></td></tr>
<tr><td><code>SPSR_ELx</code></td><td>保存异常发生时的 <strong>PSTATE（含 DAIF、EL、NZCV 等）</strong></td></tr>
<tr><td><code>ESR_ELx</code></td><td>记录<strong>异常原因</strong>（如缺页类型、未定义指令）</td></tr>
<tr><td><code>FAR_ELx</code></td><td>记录<strong>引发异常的虚拟地址</strong></td></tr>
</tbody>
</table>
</div>
<ul>
<li>由硬件在异常入口自动填充。</li>
<li>主要供异常处理程序（如内核）读取，用于决定如何响应。</li>
<li>通常不可由软件直接用于控制 CPU 行为（只读或写无效）。</li>
</ul>
<h3 id="虚拟化常见寄存器"><a class="header" href="#虚拟化常见寄存器">虚拟化常见寄存器</a></h3>
<p><strong>虚拟化控制寄存器</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>寄存器名</th><th>全称</th><th>功能说明</th><th>关键作用</th></tr>
</thead>
<tbody>
<tr><td><strong>HCR_EL2</strong></td><td>Hypervisor Configuration Register</td><td>控制虚拟化行为的各个方面</td><td>通过位设置决定哪些操作（如内存访问、指令执行）会陷阱（trap）到 EL2</td></tr>
<tr><td><strong>VTTBR_EL2</strong></td><td>Virtualization Translation Table Base Register</td><td>指向 OS 的二级页表</td><td>包含 VMID（虚拟机标识符）和 Stage-2 页表的物理基地址</td></tr>
<tr><td><strong>VTCR_EL2</strong></td><td>Virtualization Translation Control Register</td><td>控制二级地址转换（Stage-2 translation）参数</td><td>定义 IPA（Intermediate Physical Address）空间大小、页表粒度（如4KB/16KB/64KB）等</td></tr>
<tr><td><strong>TTBR0/1_EL2</strong></td><td>Translation Table Base Register</td><td>指向 OS 的一级页表</td><td>供mmu实现虚拟地址到物理地址/中间地址的转换</td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>状态与异常处理寄存器</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>寄存器名</th><th>全称</th><th>功能说明</th><th>关键作用</th></tr>
</thead>
<tbody>
<tr><td><strong>ESR_EL2</strong></td><td>Exception Syndrome Register</td><td>记录异常的详细信息</td><td>提供异常类型、指令信息等，用于 EL2 异常处理和调试</td></tr>
<tr><td><strong>FAR_EL2</strong></td><td>Fault Address Register</td><td>记录引发数据/指令访问错误的虚拟地址</td><td>用于页错误（Page Fault）诊断，指出出错的虚拟地址</td></tr>
<tr><td><strong>HPFAR_EL2</strong></td><td>Hypervisor IPA Fault Address Register</td><td>记录 Guest 物理地址（IPA）错误</td><td>在 Stage-2 地址转换失败时，提供出错的 IPA 高位（配合 FAR_EL2 使用）</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="总体架构"><a class="header" href="#总体架构">总体架构</a></h2>
<p>先来一张总体流程图，大概描述整个kvm用户空间和内核空间是如何协同工作的。</p>
<center>
    <br>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="pic/arm-kvm.jpg" width="80%">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">arm-vhe-kvm</div>

</center>
- 用户空间代码调用ioctl系统调用，触发内核kvm模块实现的函数调用，在内核的hypervisor发生上下文切换，也就是将host运行的指令保存，载入guest的指令(上下文)到CPU，在`__guest_enter`调用eret，进入guest的EL1级别继续执行PC寄存器的指令。（host el0 -&gt; host el2 -&gt; guest el1 ）
<ul>
<li>
<p>当CPU执行到敏感指令的时候，触发异常，退出guest状态，陷入到L2级别hypervisor的中断向量，中断向量很快就跳转到<code> __guest_exit</code>，<code>__guest_exit</code> ret后，CPU回到hypervisor上下文，经过fixup_guest_exit简单的处理，如果成功，则仅需切回guest。</p>
<p>如果失败，则需要继续回到host，在host内handle_exit处理捕获到的异常，当处理成功，则继续在切换到guest处理，当处理失败，则错误返回给用户空间处理，用户空间处理完成后继续调用ioctl进入内核，发生上下文切换，执行guest代码。</p>
</li>
</ul>
<p>Q：什么是用户空间代码？作用是什么？</p>
<p>A：qemu这类用户态程序。</p>
<ul>
<li>
<p>管理VM和VCPU的生命周期。</p>
</li>
<li>
<p>设备模拟和环境准备，如磁盘，内核文件，固件等；在内核无法处理异常，放到用户空间处理，比如IO，关机，信号、中断注入等。</p>
</li>
<li>
<p>分配虚拟机内存。</p>
</li>
</ul>
<p>Q：什么是上下文切换？如何切换？</p>
<p>A：上下文就是CPU寄存器状态。在x86环境中，有一个数据结构叫做VMCS，两个对象记录host和guest的上下文；在arm环境中，记录上下文用kvm_cpu_context，一个是kvm对象引用的kvm_cpu_context记录guest的上下文，通过perCPU上定义的kvm_cpu_context记录host的上下文。第一次运行的时候，要先准备好guest的上下文。整个原理是我们的核心分析过程，后面将详细描述。</p>
<p>Q：什么是guest和host？</p>
<p>A：host是宿主机执行指令的状态，guest是虚拟机执行指令的状态。当从host切换到guest执行代码的时候，需要在host执行切换相关的代码，设置CPU工作模式，CPU进入guest的工作状态，保存host的寄存器到内存，载入guest的寄存器值到CPU，然后特定的指令来模拟恢复到之前执行状态。guest状态切换到host，反之亦然。</p>
<p>在x86中，host就是vmx root mode，不过没必要去记root和none-root，只需要记住host状态和guest状态。</p>
<p>Q：什么是敏感指令？</p>
<p>A：敏感指令就是CPU虚拟化里定义的，需要特殊关注处理的指令。arm则的所有敏感指令都是特权指令，因此只有el1的状态的guest才能陷入el2。x86的敏感指令既有特权指令也有非特权指令，<strong>不必刻意去区分是否拥有特权</strong>，只需要知道他们特殊罢了。</p>
<p>CPU有各种工作模式，当你不开启虚拟化，那么就不会关注敏感指令，当开启虚拟，并通过设置特定寄存器告诉CPU要关注某些敏感指令，一旦CPU处于guest状态，流水线上发现了敏感指令，则触发中断，在中断里模拟指令的实现。</p>
<p>你可以想象一下马里奥踩到特殊地砖，进入到地下执行任务，执行完了后再次回到地上的流程，去地下就是回到host，模拟执行特殊指令。进入到host状态，这个过程叫做VM-exit，进入到guest状态的过程叫做VM-entry。</p>
<p>Q：CPU如何知道当前运行的是guest，需要去拦截敏感指令？</p>
<p>A：CPU寄存器分为控制CPU工作模式的控制寄存器，状态寄存器，执行上下文寄存器这几类。在CPU切换到guest代码之前，host代码会去操作控制寄存器，让CPU以另外一种工作模式运行，敏感指令就被监控，一旦触发就陷入异常，回到host模拟。</p>
<h2 id="关键函数"><a class="header" href="#关键函数">关键函数</a></h2>
<p><strong>关键流程</strong></p>
<pre><code class="language-txt">ioctl(vcpu_fd, KVM_RUN, NULL);//qemu
  ↓
kvm_vcpu_ioctl()
    kvm_arch_vcpu_ioctl_run()
        kvm_arm_vcpu_enter_exit()
            kvm_call_hyp_ret(__kvm_vcpu_run, vcpu)
            ├─ VHE模式: __kvm_vcpu_run_vhe() 
            └─ 非VHE模式: __kvm_vcpu_run()
                __guest_enter() (汇编实现)
                   eret (异常返回指令)
</code></pre>
<h3 id="1--用户空间代码"><a class="header" href="#1--用户空间代码">1.  用户空间代码</a></h3>
<p>来源：<a href="https://www.cnblogs.com/LoyenWang/p/13796537.html">Linux虚拟化KVM-Qemu分析（四）之CPU虚拟化（2）</a>，这份代码模拟qemu的基本工作原理：</p>
<ul>
<li>打开kvm对象，根据kvm对象创建vm对象，根据vm对象创建VCPU。</li>
<li>分配用户空间地址，将可执行二进制映射到分配的内存。</li>
<li>KVM_SET_USER_MEMORY_REGION系统调用，将分配的用户空间地址作为虚拟机的物理内存地址。</li>
<li>使用kvm实现的mmap函数，将VCPU内记录运行状态的内存共享到用户空间，方便读取从内核返回到用户空间的原因。</li>
<li>设置CPU最初始化的寻址方式，从物理内存的指定位置读取内存。(这是x86的设置方式)。</li>
<li>使用KVM_RUN启动VCPU，当系统调用返回的时候读取内核返回的原因，然后在用户空间处理，处理后继续运行VCPU。</li>
</ul>
<pre><code class="language-c">#define KVM_DEV     "/dev/kvm"
#define TINY_KERNEL_FILE    "./tiny_kernel.bin"
#define PAGE_SIZE  0x1000
int main(void)
{
    int kvm_fd;
    int vm_fd;
    int vcpu_fd;
    int tiny_kernel_fd;
    int ret;
    int mmap_size;
    
    struct kvm_sregs sregs;
    struct kvm_regs regs;
    struct kvm_userspace_memory_region mem;
    struct kvm_run *kvm_run;
    void *userspace_addr;

    /*打开kvm设备，返回代表kvm的套接字*/
    kvm_fd = open(KVM_DEV, O_RDWR);
    assert(kvm_fd &gt; 0);

    /*创建VM对象 */
    vm_fd = ioctl(kvm_fd, KVM_CREATE_VM, 0);
    assert(vm_fd &gt;= 0);

    /*根据vm对象创建vcpu对象*/
    vcpu_fd = ioctl(vm_fd, KVM_CREATE_VCPU, 0);//kvm_vm_ioctl_create_vcpu在内核创建vcpu对象
    assert(vcpu_fd &gt;= 0);

    /* map 4K into memory */
    userspace_addr = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    assert(userspace_addr &gt; 0);
    /* 打开虚拟机将运行的二进制 */

    tiny_kernel_fd = open(TINY_KERNEL_FILE, O_RDONLY);
    assert(tiny_kernel_fd &gt; 0);    
    /* 文件映射到内存 */
    ret = read(tiny_kernel_fd, userspace_addr, PAGE_SIZE);
    assert(ret &gt;= 0);
	/*将二进制映射到内存*/
    
    /*将当前进程分配的虚拟内存，作为虚拟机的物理内存*/
    mem.slot = 0;
    mem.flags = 0;
    mem.guest_phys_addr = 0;
    mem.memory_size = PAGE_SIZE;
    mem.userspace_addr = (unsigned long)userspace_addr;
    
    /*KVM_SET_USER_MEMORY_REGION将虚拟内存作为vm对象的内存，此时VCPU读取物理内存*/
    ret = ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;mem);
    assert(ret &gt;= 0);

    /* KVM_GET_VCPU_MMAP_SIZE获取kvm_run地址，这个结构体用于存储运行kvm运行状态，
    	用户空间代码通过这个结构体获取kvm的运行状态
    */
    mmap_size = ioctl(kvm_fd, KVM_GET_VCPU_MMAP_SIZE, NULL);
    assert(mmap_size &gt;= 0);
    //这里很有意思，将vcpu的内存映射到用户空间。
    kvm_run = (struct kvm_run *)mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu_fd, 0);
    assert(kvm_run &gt;= 0);

    /*sregs包含了x86架构的系统寄存器和段寄存器状态，这些寄存器控制着CPU的核心操作模式
    tiny_kernel.bin预期被加载到物理地址0，并且从16位实模式开始执行。
    */
    ret = ioctl(vcpu_fd, KVM_GET_SREGS, &amp;sregs);
    assert(ret &gt;= 0);
    sregs.cs.base = 0;
    sregs.cs.selector = 0;
    
    ret = ioctl(vcpu_fd, KVM_SET_SREGS, &amp;sregs);
    memset(&amp;regs, 0, sizeof(struct kvm_regs));
    regs.rip = 0;
    ret = ioctl(vcpu_fd, KVM_SET_REGS, &amp;regs);
    assert(ret &gt;= 0);

    /* 指定一个cpu运行，一个CPU对应一个kvm_run结构体 */
    while (1) {
        ret = ioctl(vcpu_fd, KVM_RUN, NULL);ioctl(vcpu_fd, KVM_RUN, NULL);
        assert(ret &gt;= 0);

        switch(kvm_run-&gt;exit_reason) {
            case KVM_EXIT_HLT:
                printf("----KVM EXIT HLT----\n");
                close(kvm_fd);
                close(tiny_kernel_fd);
                return 0;
            case KVM_EXIT_IO:
                putchar(*(((char *)kvm_run) + kvm_run-&gt;io.data_offset));
                break;
            default:
                printf("Unknow exit reason: %d\n", kvm_run-&gt;exit_reason);
                break;
        }
    }

    return 0;
}
</code></pre>
<h3 id="2-kvm驱动实现"><a class="header" href="#2-kvm驱动实现">2. kvm驱动实现</a></h3>
<h4 id="kvm_run系统调用入口"><a class="header" href="#kvm_run系统调用入口">KVM_RUN系统调用入口</a></h4>
<p>ioctl(vcpu_fd, KVM_RUN, NULL)实际调用的对应在内核中的处理逻辑如下：</p>
<pre><code class="language-c">static long kvm_vcpu_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
{
	struct kvm_vcpu *vcpu = filp-&gt;private_data;//从套接字对应的filp对象中获取vcpu对象。
    ....
	switch (ioctl) {
	case KVM_RUN: {
        ....
		r = kvm_arch_vcpu_ioctl_run(vcpu);//关键入口，返回整数r,错误原因
		....
		break;
	}
...
}     

</code></pre>
<p>在host处理异常，在kvm_arch_vcpu_ioctl_run内，都还属于host kernel的范围，kvm_arm_vcpu_enter_exit这是在准备进入到hypervisor。handle_exit处理异常，处理成功则继续循环，处理失败则返回，最终回到用户空间。</p>
<pre><code class="language-c">int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
{
	struct kvm_run *run = vcpu-&gt;run;
	int ret;

	if (run-&gt;exit_reason == KVM_EXIT_MMIO) {
		ret = kvm_handle_mmio_return(vcpu);
		if (ret)
			return ret;
	}

	vcpu_load(vcpu);

	if (run-&gt;immediate_exit) {
		ret = -EINTR;
		goto out;
	}

	kvm_sigset_activate(vcpu);

	ret = 1;
	run-&gt;exit_reason = KVM_EXIT_UNKNOWN;
	run-&gt;flags = 0;
	while (ret &gt; 0) {
        ...
		ret = kvm_arm_vcpu_enter_exit(vcpu);
        ...
		ret = handle_exit(vcpu, ret);
	}
    ...
	return ret;
}

static int noinstr kvm_arm_vcpu_enter_exit(struct kvm_vcpu *vcpu)
{
	int ret;

	guest_state_enter_irqoff();
	ret = kvm_call_hyp_ret(__kvm_vcpu_run, vcpu);//封装
	guest_state_exit_irqoff();

	return ret;
}
</code></pre>
<h4 id="vhe模式"><a class="header" href="#vhe模式">VHE模式</a></h4>
<h5 id="nvhe"><a class="header" href="#nvhe">nVHE</a></h5>
<p>kvm_call_hyp_ret算是host和hypervisor的分界线，这里根据 has_vhe()判断是否启用了VHE，决定使用哪种调用。</p>
<ul>
<li>在非VHE模式模式中，<strong>kvm_call_hyp_ret()</strong> 宏走kvm_call_hyp_nvhe路径，调用<strong>arm_smccc_1_1_hvc</strong>，会触发一个 HVC 指令，把当前正在运行在内核中EL1状态的 CPU陷入 EL2，才能执行host和guest的上下文切换，进入到guest的。也就是说，在内核中的<strong>kvm模块需要再次陷入</strong>到更高的异常级别才能操作硬件资源。</li>
<li>VHE模式中，Linux 内核本身就在 EL2 运行，所以直接调用 f() 同样是在 EL2 中，不用陷入到EL2。</li>
</ul>
<pre><code class="language-c">#ifndef __KVM_NVHE_HYPERVISOR__
#define kvm_call_hyp_nvhe(f, ...)						\
	({								\
		struct arm_smccc_res res;				\
									\
		arm_smccc_1_1_hvc(KVM_HOST_SMCCC_FUNC(f),		\
				  ##__VA_ARGS__, &amp;res);			\
		WARN_ON(res.a0 != SMCCC_RET_SUCCESS);			\
									\
		res.a1;							\
	})

/*
 * The isb() below is there to guarantee the same behaviour on VHE as on !VHE,
 * where the eret to EL1 acts as a context synchronization event.
 */
#define kvm_call_hyp(f, ...)						\
	do {								\
		if (has_vhe()) {					\
			f(__VA_ARGS__);					\
			isb();						\
		} else {						\
			kvm_call_hyp_nvhe(f, ##__VA_ARGS__);		\
		}							\
	} while(0)

#define kvm_call_hyp_ret(f, ...)					\
	({								\
		typeof(f(__VA_ARGS__)) ret;				\
									\
		if (has_vhe()) {					\
			ret = f(__VA_ARGS__);				\
		} else {						\
			ret = kvm_call_hyp_nvhe(f, ##__VA_ARGS__);	\
		}							\
									\
		ret;							\
	})
#else /* __KVM_NVHE_HYPERVISOR__ */
#define kvm_call_hyp(f, ...) f(__VA_ARGS__)
#define kvm_call_hyp_ret(f, ...) f(__VA_ARGS__)
#define kvm_call_hyp_nvhe(f, ...) f(__VA_ARGS__)
</code></pre>
<p>从这里可以看出nVHE模式， kvm_call_hyp_ret是el1到el2的标志。将hyp和host做了区分。</p>
<pre><code class="language-c">kvm_arch_vcpu_ioctl_run()
{
    while (ret &gt; 0) {
        ...
    	ret = kvm_arm_vcpu_enter_exit(vcpu);//这里进入,内部就是kvm_call_hyp_ret提权操作
        ...
    	ret = handle_exit(vcpu, ret);//host处理，处理不了就再返回
    }
}
</code></pre>
<p>在之前的arm规范中，严格区分了内核代码运行在EL1和hypervisor运行在EL2，也就是nVHE模式的kvm实现。</p>
<p>进入guest：</p>
<ul>
<li>当用户启动虚拟机的时候，要先系统调用进入内核(Host EL1)，内核再<strong>通过HVC 指令进入EL2</strong>级别的执行hypervisor代码，hypervisor进入到guest代码运行。</li>
</ul>
<p>退出guest：</p>
<ul>
<li>同样，guest代码运行的时候访问io资源，guest处于el1的状态，执行的敏感指令被拦截，陷入到EL2级里的hypervisor执行，在EL2内的hypervisor只能处理简单的异常，大部分异常需要继续返回。再从EL2返回到EL1的内核态的kvm模块处理，在EL1内核态再返回给用户。</li>
<li>用户态处理完后还要通过系统调用，如一开始运行那样进入guest执行。</li>
</ul>
<h5 id="vhe"><a class="header" href="#vhe">VHE</a></h5>
<p>为了减少这么多步骤的异常级切换，直接让hypervisor和内核工作在一个异常级别即可。ARMv8.1 通过以下机制，使得内核运行在 EL2 ：
HCR_EL2.E2H = 1（Enable EL2 Host）,    当此位为 1 时，EL2 的行为被“重塑”：</p>
<ul>
<li>
<p>访问 TTBR0_EL1 实际操作的是 TTBR0_EL2，也就是说，之前的内核代码不用修改访问寄存器的指令，就可以访问TTBR0_EL2(页表寄存器)。</p>
</li>
<li>
<p>SPSR_EL1、ELR_EL1 等寄存器在 EL2 中可用</p>
</li>
<li>
<p>系统调用（SVC）可以从 EL0 直接陷入 EL2（而非 EL1）</p>
<p>效果：相当于取消host EL1，直接让内核工作在EL2。</p>
</li>
</ul>
<p>HCR_EL2.TGE = 1（Trap General Exceptions）</p>
<ul>
<li>配合 E2H，使 EL0 的异常（如 SVC、IRQ）直接路由到 EL2。</li>
</ul>
<p>Stage-1 页表支持</p>
<ul>
<li>
<p>即使在 EL2，也可以使用自己的 Stage-1 页表（通过 TTBR0_EL2 / TTBR1_EL2），实现虚拟地址空间。</p>
</li>
<li>
<p>但 Linux 内核严重依赖虚拟内存（<code>vmalloc</code>, <code>slab</code>, 用户态映射等）。</p>
</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>机制</th><th>解决的问题</th><th>实现效果</th></tr>
</thead>
<tbody>
<tr><td><strong><code>E2H=1</code></strong></td><td>EL2 无法使用 EL1 寄存器</td><td><strong>寄存器别名映射</strong>，Linux 代码无需修改</td></tr>
<tr><td><strong><code>TGE=1</code></strong></td><td>EL0 异常无法路由到 EL2</td><td><strong>异常直接陷入 EL2</strong>，Host 能处理 syscall/IRQ</td></tr>
<tr><td><strong>Stage-1 in EL2</strong></td><td>EL2 无虚拟内存支持</td><td><strong>完整虚拟地址空间</strong>，支持现代 OS 内存管理</td></tr>
</tbody>
</table>
</div>
<p>最终，本质上kvm和内核都工作在EL2，host上只有EL0和EL2，根x86差不多。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="pic/nvhe_vs_vhe.png" width="50%">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">nvhe-vs-vhe</div>

</center>
<hr>
<h4 id="arm-kvm上下文切换实现"><a class="header" href="#arm-kvm上下文切换实现">ARM KVM上下文切换实现</a></h4>
<h4 id="__kvm_vcpu_run_vhe函数"><a class="header" href="#__kvm_vcpu_run_vhe函数">__kvm_vcpu_run_vhe函数</a></h4>
<p>在寄存器分类中，我们知道分为执行上下文，系统控制，异常状态这几类，所以进入上下文切换之前，需要：</p>
<ul>
<li>保存一些host的CPU运行状态</li>
<li>设置CPU进入虚拟化执行的工作模式</li>
<li>恢复恢复guest的CPU运行状态，有了运行状态，guest在el1的系统就有了运行逻辑的参考依据，一旦切换执行上下文成功，比如栈寄存器和PC寄存器就位，马上就可以开始有条不紊的工作。</li>
</ul>
<p>arm PC寄存器不能直接填入将指令的地址，需要将地址放入ELR_ELx，当执行 <code>eret</code> 的时候，ELR_ELx的值被自动弹入到PC，SPSR_ELx弹入到PSTATE，切换到 <code>SPSR_ELx</code> 指定的异常级别开始取指运行。也就是进入到guest的el1的内核态开始执行。</p>
<pre><code class="language-c">/* Switch to the guest for VHE systems running in EL2 */
static int __kvm_vcpu_run_vhe(struct kvm_vcpu *vcpu)
{
	struct kvm_cpu_context *host_ctxt;
	struct kvm_cpu_context *guest_ctxt;
	u64 exit_code;

	host_ctxt = host_data_ptr(host_ctxt);
	guest_ctxt = &amp;vcpu-&gt;arch.ctxt;

	fpsimd_lazy_switch_to_guest(vcpu);

	sysreg_save_host_state_vhe(host_ctxt);

	/*
	 * Note that ARM erratum 1165522 requires us to configure both stage 1
	 * and stage 2 translation for the guest context before we clear
	 * HCR_EL2.TGE. The stage 1 and stage 2 guest context has already been
	 * loaded on the CPU in kvm_vcpu_load_vhe().
	 */
	__activate_traps(vcpu);//设置捕获敏感指令，x86是通过vmcs里的字段控制，由特定指令载入寄存器。

	__kvm_adjust_pc(vcpu);
	//Guest 关键寄存器（如 ELR_EL2）设置放在 C 层,__guest_enter汇编只负责上下文切换。
	sysreg_restore_guest_state_vhe(guest_ctxt);//设置guest的PC寄存器值elr寄存器，方便eret

	do {
		/* Jump in the fire! */
		exit_code = __guest_enter(vcpu);//这里bl__guest_enter，lr寄存器记录返回地址。最终__guest_exit执行ret，返回exit_code

		/* And we're baaack! */
	} while (fixup_guest_exit(vcpu, &amp;exit_code));//如果可以在el2快速处理就直接处理，不能则回到用户空间。

	sysreg_save_guest_state_vhe(guest_ctxt);

	__deactivate_traps(vcpu);

	sysreg_restore_host_state_vhe(host_ctxt);

	/*
	 * Ensure that all system register writes above have taken effect
	 * before returning to the host. In VHE mode, CPTR traps for
	 * FPSIMD/SVE/SME also apply to EL2, so FPSIMD/SVE/SME state must be
	 * manipulated after the ISB.
	 */
	isb();
	...
	return exit_code;
}
NOKPROBE_SYMBOL(__kvm_vcpu_run_vhe);

//sysreg-sr.c  
void sysreg_restore_guest_state_vhe(struct kvm_cpu_context *ctxt) {
    __sysreg_restore_common_state(ctxt);
    __sysreg_restore_el2_return_state(ctxt);
}    
//sysreg-sr.h：
static inline void __sysreg_restore_el2_return_state(struct kvm_cpu_context *ctxt) {
    // ...
    write_sysreg_el2(ctxt-&gt;regs.pc, SYS_ELR);//将PC值写入elr寄存器，方便eret
    write_sysreg_el2(pstate, SYS_SPSR);
}
</code></pre>
<h4 id="__guest_enter汇编入口"><a class="header" href="#__guest_enter汇编入口">__guest_enter汇编入口</a></h4>
<p>__guest_enter的实现：</p>
<ul>
<li>
<p>保存hyp上下文到kvm_hyp_ctxt，包括处于el2运行级别的通用寄存器和el0级的host用户栈sp_el0。</p>
</li>
<li>
<p>恢复guest上下文，处于el1运行级别的通用寄存器和el0级的guest用户栈sp_el0。</p>
</li>
<li>
<p>eret跳转到guest的PC寄存器，开始执行。</p>
<pre><code class="language-c">// Restore guest regs x0-x17,
// Restore guest regs x18-x29和lr
恢复上下文这里，为啥分成两段写，我觉得有点奇怪。
</code></pre>
</li>
</ul>
<p>guest代码执行到敏感指令，触发异常，从guest的el1陷入到host的el2，进入el2_sync向量，这是一段垫片代码，最终执行到__guest_exit，将perCPU变量上保存的vcpu地址作为参数。</p>
<p>虽然guest陷入到el2，也是中断向量处理，但是hypervisor的中断向量不像内核的系统调用和中断那样先将用户态的上下文压栈保存到内核，返回用户态的时候恢复。不管是guest el1还是el0陷入el2，el2也只是使用sp_el2，sp_el1还静静的在哪，当返回到guest用户空间的时候，sp_el0会被覆盖。因此在切换回guest的时候，只需要恢复sp_el0，guest el1和el0的栈寄存器都和切换之前一样。</p>
<pre><code class="language-asm">// arch/arm64/kvm/hyp/hyp-entry.S

el2_sync:
	/* Check for illegal exception return */
	mrs	x0, spsr_el2//读取到x0，spsr_el2记录了异常发生前的 PSTATE（如异常级、条件码、中断屏蔽等）
	tbnz	x0, #20, 1f //如果 SPSR_EL2 的 SS 位为 1，说明这是一个非法的 ERET 异常，就跳转到标签 1 处进行特殊处理。

	save_caller_saved_regs_vect //保存所有调用者保存的寄存器到堆栈上
	stp     x29, x30, [sp, #-16]! //将帧指针 x29 和链接寄存器 x30 压栈。这是在为调用 C 函数准备标准的堆栈帧。
	bl	kvm_unexpected_el2_exception //进入异常处理
	ldp     x29, x30, [sp], #16
	restore_caller_saved_regs_vect

	eret

1:
	/* Let's attempt a recovery from the illegal exception return */
	get_vcpu_ptr	x1, x0 //获取percpu上保存的vcpu传入给__guest_exit
	mov	x0, #ARM_EXCEPTION_IL
	b	__guest_exit

el1_sync:  // 同步异常（如 Data Abort）
    ...
	b.ne	el1_trap
el1_trap:
	get_vcpu_ptr	x1, x0
	mov	x0, #ARM_EXCEPTION_TRAP
	b	__guest_exit

//u64 __guest_enter(struct kvm_vcpu *vcpu);
SYM_FUNC_START(__guest_enter)
	// x0: vcpu，又是返回值
	// x1-x17: clobbered by macros
	// x29: guest context
    // x2 辅助计算。
	adr_this_cpu x1, kvm_hyp_ctxt, x2 //从cpu上获取 kvm_cpu_context对象的地址

	// Store the hyp regs
	save_callee_saved_regs x1//将当前调用者(已经进入到el2了，当前调用这个函数的就是hyp)x18-x30的寄存器保存到上下文。

	// Save hyp's sp_el0
	save_sp_el0	x1, x2 //将用户空间栈sp_el0保存到kvm_hyp_ctxt上下文。在进入__guest_enter前，都是执行Hypervisor的C代码，先系统调用，。
    //将hyp的上下文记录完。

	// Now the hyp state is stored if we have a pending RAS SError it must
	// affect the host or hyp. If any asynchronous exception is pending we
	// defer the guest entry. The DSB isn't necessary before v8.2 as any
	// SError would be fatal.
alternative_if ARM64_HAS_RAS_EXTN
	dsb	nshst
	isb
alternative_else_nop_endif
	mrs	x1, isr_el1
	cbz	x1,  1f
	mov	x0, #ARM_EXCEPTION_IRQ
	ret
1:
	set_loaded_vcpu x0, x1, x2

	add	x29, x0, #VCPU_CONTEXT，取x0的偏移赋值给x29,x29=vcpu-&gt;kvm_cpu_context

	// mte_switch_to_guest(g_ctxt, h_ctxt, tmp1)
	mte_switch_to_guest x29, x1, x2

	// Macro ptrauth_switch_to_guest format:
	// 	ptrauth_switch_to_guest(guest cxt, tmp1, tmp2, tmp3)
	// The below macro to restore guest keys is not implemented in C code
	// as it may cause Pointer Authentication key signing mismatch errors
	// when this feature is enabled for kernel code.
	ptrauth_switch_to_guest x29, x0, x1, x2

	// Restore the guest's sp_el0
	restore_sp_el0 x29, x0//将vcpu的sp_el0恢复到sp_el0，用户栈

	// Restore guest regs x0-x17,从x29的偏移取一对数据。
	ldp	x0, x1,   [x29, #CPU_XREG_OFFSET(0)]
	ldp	x2, x3,   [x29, #CPU_XREG_OFFSET(2)]
	ldp	x4, x5,   [x29, #CPU_XREG_OFFSET(4)]
	ldp	x6, x7,   [x29, #CPU_XREG_OFFSET(6)]
	ldp	x8, x9,   [x29, #CPU_XREG_OFFSET(8)]
	ldp	x10, x11, [x29, #CPU_XREG_OFFSET(10)]
	ldp	x12, x13, [x29, #CPU_XREG_OFFSET(12)]
	ldp	x14, x15, [x29, #CPU_XREG_OFFSET(14)]
	ldp	x16, x17, [x29, #CPU_XREG_OFFSET(16)]

	// Restore guest regs x18-x29和lr
	restore_callee_saved_regs x29 //从vcpu恢复lr
	//为什么elr_el2不在这里恢复？要在sysreg_restore_guest_state_vhe
	
	// Do not touch any register after this!
	eret	//这里跳转到elr_el2，也就是VCPU的PC,进入guest代码执行
/*
用户空间（EL0）通过 ioctl 进入 KVM 内核代码（EL1）。
内核代码（EL1）最终调用 __kvm_vcpu_run，准备好上下文后，通过 SMC/HVC 或跳转机制切换到 EL2。
在 EL2 下，执行 __guest_enter，完成虚拟机上下文切换，eret 进入 Guest（EL1/EL0）。
*/
	sb 
	
/*sb 指令是 ARMv8 架构中的 “Speculation Barrier”（推测屏障）指令。
作用：
用于防止 CPU 执行推测性指令带来的安全隐患（如 Spectre 类漏洞）。
它会阻止指令流中在 sb 之前的所有内存访问被推测性地重排序到 sb 之后。
确保异常返回前后的执行环境不会被推测执行影响，提升安全性。
*/
</code></pre>
<h4 id="__guest_exit"><a class="header" href="#__guest_exit">__guest_exit</a></h4>
<p>__guest_exit的实现：</p>
<ul>
<li>从vcpu获取kvm_cpu_context对象（vcpu-&gt;kvm_cpu_context）。将guest上下文保存到kvm_cpu_context对象，guest的通用寄存器和sp_el0。</li>
<li>将从percpu获取kvm_hyp_ctxt对象，恢复host上下文，sp_el0和通用寄存器（当然包括lr/x30寄存器）。</li>
<li>ret 跳转到__guest_enter的下一条指令，<code> exit_code=__guest_enter</code> 后的指令，此时以及回到hyp的C上下文。</li>
</ul>
<pre><code class="language-asm">
// arch/arm64/kvm/hyp/entry.S
SYM_INNER_LABEL(__guest_exit, SYM_L_GLOBAL)
	// x0: return code
	// x1: vcpu
	// x2-x29,lr: vcpu regs
	// vcpu x0-x1 on the stack
0
	add	x1, x1, #VCPU_CONTEXT//x1指向vcpu的vcpu_context

	ALTERNATIVE(nop, SET_PSTATE_PAN(1), ARM64_HAS_PAN, CONFIG_ARM64_PAN)

	// Store the guest regs x2 and x3
	stp	x2, x3,   [x1, #CPU_XREG_OFFSET(2)]

	// Retrieve the guest regs x0-x1 from the stack
	ldp	x2, x3, [sp], #16	// x0, x1

	// Store the guest regs x0-x1 and x4-x17
	stp	x2, x3,   [x1, #CPU_XREG_OFFSET(0)]
	stp	x4, x5,   [x1, #CPU_XREG_OFFSET(4)]
	stp	x6, x7,   [x1, #CPU_XREG_OFFSET(6)]
	stp	x8, x9,   [x1, #CPU_XREG_OFFSET(8)]
	stp	x10, x11, [x1, #CPU_XREG_OFFSET(10)]
	stp	x12, x13, [x1, #CPU_XREG_OFFSET(12)]
	stp	x14, x15, [x1, #CPU_XREG_OFFSET(14)]
	stp	x16, x17, [x1, #CPU_XREG_OFFSET(16)]
//依次将 x0-x17 的值保存到 vcpu 的上下文结构体（VCPU_CONTEXT）对应偏移。
//这样做保证异常发生时，Guest 的所有通用寄存器都能被 Hypervisor 完整保存。
	// Store the guest regs x18-x29, lr
	save_callee_saved_regs x1

	// Store the guest's sp_el0
	save_sp_el0	x1, x2
//先保存vcpu上下文，在加载percpu绑定的变量上面的host cpu上下文，这个上下文是切换到guest前保存的。
	adr_this_cpu x2, kvm_hyp_ctxt, x3 //load cpu上找到切换前的上下文到x2，切换前是cpu上下文是Hypervisor的代码。

	// Macro ptrauth_switch_to_hyp format:
	// 	ptrauth_switch_to_hyp(guest cxt, host cxt, tmp1, tmp2, tmp3)
	// The below macro to save/restore keys is not implemented in C code
	// as it may cause Pointer Authentication key signing mismatch errors
	// when this feature is enabled for kernel code.
	ptrauth_switch_to_hyp x1, x2, x3, x4, x5

	// mte_switch_to_hyp(g_ctxt, h_ctxt, reg1)
	mte_switch_to_hyp x1, x2, x3

	// Restore hyp's sp_el0
	restore_sp_el0 x2, x3 //从x2里恢复sp_el0，hyp的C代码执行环境。
/*
host 可以el2内核和hyp，el0用户态
guest 可以el1内核，el0用户态
不管是guest还是host，只有一个用户异常级别sp_el0可用，因此要保存以及恢复。

vcpu-&gt;arch.ctxt.sp 保存 Guest 的 SP_EL0
kvm_hyp_ctxt.sp（per-CPU）保存 hyp/Host 的 SP_EL0，也就是qemu的栈。
*/
	// Now restore the hyp regs
	restore_callee_saved_regs x2 //从x2对象里恢复寄存器，包括lr。

	set_loaded_vcpu xzr, x2, x3

alternative_if ARM64_HAS_RAS_EXTN
	// If we have the RAS extensions we can consume a pending error
	// without an unmask-SError and isb. The ESB-instruction consumed any
	// pending guest error when we took the exception from the guest.
	mrs_s	x2, SYS_DISR_EL1
	str	x2, [x1, #(VCPU_FAULT_DISR - VCPU_CONTEXT)]
	cbz	x2, 1f
	msr_s	SYS_DISR_EL1, xzr
	orr	x0, x0, #(1&lt;&lt;ARM_EXIT_WITH_SERROR_BIT)
1:	ret
/*__guest_exit直接的返回值就是__guest_enter一次guest的返回值*/

</code></pre>
<p>整体上，可以把__guest_enter看做一个执行上下文切换并运行guest代码的函数。</p>
<p>我们在回到_kvm_arch_vcpu_ioctl_run来看，不管是_<code>__kvm_vcpu_run</code>还是<code>__kvm_vcpu_run_vhe</code>，都有eret进入guest，从<code>__guest_exit</code>返回只有ret返回，也就是任然工作在el2。</p>
<p>nvhe严格的划分：host部分代码运行在el1，hyp部分运行el2。那么什么时候实现 hyp el2会到host el1的呢？答案就在<code>kvm_call_hyp_ret</code>宏，它的返回就代表从el2回到了el1，会单独开辟nvhe流程章节分析讲解。</p>
<hr>
<h3 id="3-stage-2-地址翻译"><a class="header" href="#3-stage-2-地址翻译">3. Stage-2 地址翻译</a></h3>
<p>host和guest上下文切换属于CPU虚拟化的知识范畴，stage-2地址翻译属于内存虚拟化的范畴，但是这两者紧密相关。所以在这里会简单的做一些介绍。</p>
<p>当CPU切换到guest后，从PC寄存器保存的地址取指运行，就涉及到度内存的访问。</p>
<p>在host用户空间分配的虚拟地址，作为虚拟机的物理地址，CPU是如何读取上面的数据并执行的呢？</p>
<pre><code class="language-c">// QEMU
ioctl(fd, KVM_CREATE_VM, type)；//最终会调用kvm_init_stage2_mmu创建页表。
void *ram = mmap(NULL, 0x1000000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
// ram = 0x7f1234560000 (Host userspace VA)，host用户空间分配的地址。

// 告诉 KVM：Guest 的 0x0 ~ 0x1000000 是 RAM
kvm_userspace_memory_region reg = {
    .guest_phys_addr = 0x0,
    .memory_size     = 0x1000000,
    .userspace_addr  = (uint64_t)ram,
};
ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;reg);
// 此时 Host 物理页尚未分配（可能还在 swap 或 zero page）
</code></pre>
<p>kvm对象创建的时候，就会给S2页表对象创建，<strong>保证VTTBR_EL2不为空。</strong></p>
<p>此时，我们将ELR_EL2 = 0x0，SCTLR_EL1.M = 0（关闭MMU，不启用S1翻译，所以不用判段地址是高还是低，不适用TTBR0_EL1/TTBR1_EL1），执行eret的时候，PC寄存器开始从0x0的物理虚拟物理地址开始读取。</p>
<pre><code class="language-c">PC = 0x0 (VA)
  ↓
Stage-1 （SCTLR_EL1.M=0，，通常 MMU 关闭，假设 Guest 尚未设置页表，如刚启动），
  → 不翻译。（不使用 Guest TTBR0_EL1/TTBR1_EL1 ）
  → 此时 VA = IPA = 0x0
  ↓
Stage-2 （HCR_EL2.VM = 1，开启翻译）
  → 部件TLB未命中 → 页表walk发现PTE无效 → 触发Stage-2 Translation Fault → Trap到kvm EL2处理缺页。→ __guest_exit退出
    ...-&gt;直到kvm_arch_vcpu_ioctl_run-&gt;
        -&gt;handle_exit-&gt;handle_trap_exceptions（处理ESR_ELx_EC_IABT_LOW异常）
        	-&gt;...-&gt;user_mem_abort（处理内存错误）-&gt;kvm_pgtable_stage2_map（实现填充页表项，刷新页表缓存）//在el2内处理完后handle_exit返回。
        -&gt;kvm_arm_vcpu_enter_exit -&gt; ...-&gt;__guest_enter //根据handle_exit返回值，决定继续进入guest执行。
  → IPA 0x0 已被你映射到 Host 的 ram 物理页（使用VTTBR_EL2页表寄存器）
  → 再次访问IPA=0x0，得到真实 PA
  ↓
从该物理页读取指令 → 成功！
</code></pre>
<p>如果开启Stage-1翻译，相当于KVM_SET_USER_MEMORY_REGION提供了物理地址(IPA)给guest EL1内核，guest内核负责管理物理内存，以及创建Stage-1的页表，就是内核正常的初始化物理内存的过程。guest的虚拟地址，都是要通过其 EL1内核分配。</p>
<h2 id="关键数据结构和寄存器"><a class="header" href="#关键数据结构和寄存器">关键数据结构和寄存器</a></h2>
<pre><code class="language-text">kvm (虚拟机实例)
├── 内存管理
│   ├── kvm_memslots[] (内存插槽)
│   └── mmu_lock (MMU锁)
├── vCPU数组
│   └── kvm_vcpu[] (虚拟CPU)
│       ├── 用户空间接口
│       │   └── kvm_run (通信接口)
│       └── 架构特定状态
│           └── kvm_vcpu_arch
│               ├── CPU上下文
│               │   └── kvm_cpu_context
│               │       ├── regs (通用寄存器)
│               │       ├── fp_regs (FP/SIMD寄存器)
│               │       └── sys_regs (系统寄存器)
│               ├── 地址转换
│               │   └── kvm_s2_mmu *hw_mmu
│               │       ├── vmid (虚拟机ID)
│               │       ├── pgd_phys (页表物理地址)
│               │       └── pgt (页表结构)
│               ├── 虚拟外设
│               │   ├── vgic_cpu (虚拟中断控制器)
│               │   ├── timer (虚拟定时器)
│               │   └── pmu (性能监控单元)
│               └── 嵌套虚拟化
│                   └── *nested_mmus
└── 架构特定数据
    └── kvm_arch

Per-CPU Host状态
└── kvm_host_data[]
    └── host_ctxt (Host CPU上下文)
        ├── regs (Host寄存器)
        ├── fp_regs (Host FP状态)
        └── sys_regs (Host系统寄存器)
</code></pre>
<h3 id="1-kvm---虚拟机实例"><a class="header" href="#1-kvm---虚拟机实例">1. kvm - 虚拟机实例</a></h3>
<p><strong>文件位置</strong>: <code>include/linux/kvm_host.h</code></p>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm {
#ifdef KVM_HAVE_MMU_RWLOCK
    rwlock_t mmu_lock;
#else
    spinlock_t mmu_lock;
#endif
    struct mutex slots_lock;
    struct mutex slots_arch_lock;
    struct mm_struct *mm;               // 用户空间内存描述符
    unsigned long nr_memslot_pages;
    struct kvm_memslots __memslots[KVM_MAX_NR_ADDRESS_SPACES][2]; // 内存插槽
    struct kvm_vcpu *vcpus[KVM_MAX_VCPUS]; // vCPU数组
    struct kvm_arch arch;               // 架构特定数据
    atomic_t online_vcpus;             // 在线vCPU计数
    long vcpus_in_guest;                // 在guest中的vCPU数
};
</code></pre>
<p><strong>主要作用</strong>：</p>
<ul>
<li>代表一个完整的虚拟机实例</li>
<li>管理虚拟机的内存、设备和vCPU</li>
<li>提供虚拟机级别的配置和控制</li>
</ul>
<h3 id="2-kvm_vcpu---虚拟cpu核心结构体"><a class="header" href="#2-kvm_vcpu---虚拟cpu核心结构体">2. kvm_vcpu - 虚拟CPU核心结构体</a></h3>
<pre><code class="language-c">struct kvm_vcpu {
    struct kvm *kvm;                    // 所属虚拟机实例
    int cpu, vcpu_id, vcpu_idx;         // 物理CPU映射和虚拟ID
    struct kvm_run *run;                // 用户空间通信结构
    struct kvm_vcpu_arch arch;          // 架构特定状态
    struct kvm_vcpu_stat stat;          // 统计信息
    int mode;                           // 执行模式(IN_GUEST_MODE等)
    bool wants_to_run;                  // 运行意愿标记
    int preempted;                      // 抢占状态
    void *guest_debug;                  // 调试支持
};
</code></pre>
<p><strong>主要作用</strong>：</p>
<ul>
<li>代表一个虚拟CPU实例，是虚拟化的基本单位</li>
<li>管理vCPU的生命周期和调度</li>
<li>协调guest和host之间的状态切换</li>
<li>提供统计信息跟踪和性能监控</li>
</ul>
<h3 id="3-kvm_run---用户空间通信接口"><a class="header" href="#3-kvm_run---用户空间通信接口">3. kvm_run - 用户空间通信接口</a></h3>
<p><strong>文件位置</strong>: <code>include/uapi/linux/kvm.h</code></p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>作为用户空间和内核空间KVM的通信桥梁</li>
<li>传递guest退出原因和处理请求</li>
<li>提供同步接口和数据交换</li>
</ul>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm_run {
    __u8 request_interrupt_window;      // 请求中断窗口
    __u8 immediate_exit;                // 立即退出标记
    __u8 padding1[6];
    __u32 exit_reason;                  // 退出原因
    __u8 ready_for_interrupt_injection; // 中断注入准备状态
    __u8 if_flag;                       // 中断标志
    __u16 flags;                        // 状态标志
    __u64 cr8;                          // x86 CR8寄存器
    __u64 apic_base;                    // APIC基地址
    // 架构特定的退出信息联合体
};
</code></pre>
<h3 id="4-kvm_vcpu_arch---arm架构特定的vcpu状态"><a class="header" href="#4-kvm_vcpu_arch---arm架构特定的vcpu状态">4. kvm_vcpu_arch - ARM架构特定的vCPU状态</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_host.h</code></p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>存储ARM架构特定的vCPU完整状态</li>
<li>包含guest的处理器上下文和虚拟化配置</li>
<li>管理ARM特定的虚拟化特性</li>
</ul>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm_vcpu_arch {
    struct kvm_cpu_context ctxt;        // CPU上下文(核心)
    void *sve_state;                    // SVE(可伸缩向量扩展)状态
    enum fp_type fp_type;               // 浮点类型
    struct kvm_s2_mmu *hw_mmu;          // 二级地址转换MMU
    u64 hcr_el2, hcrx_el2, mdcr_el2;    // 虚拟化控制寄存器
    struct kvm_vcpu_fault_info fault;  // 缺页错误信息
    struct vgic_cpu vgic_cpu;           // 虚拟GIC状态
    struct kvm_timer timer;             // 虚拟定时器
    struct kvm_pmu pmu;                 // 性能监控单元
    u64 trfcr_while_in_guest;          // 跟踪过滤器配置
    struct kvm_s2_mmu mmu;              // 二级MMU
    struct kvm_s2_mmu *nested_mmus;     // 嵌套虚拟化MMU
};
</code></pre>
<p><strong>关键特性</strong>：</p>
<ul>
<li><code>ctxt</code>字段是上下文切换的核心</li>
<li><code>hw_mmu</code>指向实际使用的地址转换结构</li>
<li>支持嵌套虚拟化(nested_mmus)</li>
<li>包含完整的虚拟外设状态(GIC、定时器、PMU)</li>
</ul>
<h3 id="5-kvm_cpu_context---cpu上下文状态"><a class="header" href="#5-kvm_cpu_context---cpu上下文状态">5. kvm_cpu_context - CPU上下文状态</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_host.h</code></p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>存储完整的CPU寄存器状态</li>
<li>在上下文切换时保存和恢复处理器状态</li>
<li>作为guest和host状态切换的载体</li>
</ul>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm_cpu_context {
    struct user_pt_regs regs;           // 通用寄存器(x0-x30, sp, pc)
    u64 spsr_abt, spsr_und, spsr_irq, spsr_fiq;  // 异常状态寄存器
    struct user_fpsimd_state fp_regs;   // FP/SIMD寄存器
    u64 sys_regs[NR_SYS_REGS];          // 系统寄存器
    struct kvm_vcpu *__hyp_running_vcpu; // hypervisor运行中的vCPU
    u64 *vncr_array;                    // 嵌套虚拟化寄存器
};
</code></pre>
<p><strong>寄存器组分类</strong>：</p>
<ol>
<li><strong>通用寄存器</strong> (regs): x0-x30, sp, pc</li>
<li><strong>异常状态寄存器</strong>: SPSR_ABT, SPSR_UND, SPSR_IRQ, SPSR_FIQ</li>
<li><strong>浮点/SIMD寄存器</strong> (fp_regs): V0-V31, FPSR, FPCR</li>
<li><strong>系统寄存器</strong> (sys_regs): SCTLR, TCR, TTBR等</li>
</ol>
<h3 id="6-kvm_host_data---host状态管理"><a class="header" href="#6-kvm_host_data---host状态管理">6. kvm_host_data - Host状态管理</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_host.h</code></p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>管理hypervisor的host状态</li>
<li>提供Per-CPU数据存储</li>
<li>管理host的系统寄存器上下文</li>
</ul>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm_host_data {
#define KVM_HOST_DATA_FLAG_HAS_SPE            0
#define KVM_HOST_DATA_FLAG_HAS_TRBE           1
#define KVM_HOST_DATA_FLAG_TRBE_ENABLED       4
#define KVM_HOST_DATA_FLAG_EL1_TRACING_CONFIGURED  5
#define KVM_HOST_DATA_FLAG_VCPU_IN_HYP_CONTEXT   6
#define KVM_HOST_DATA_FLAG_L1_VNCR_MAPPED       7
#define KVM_HOST_DATA_FLAG_HAS_BRBE           8
    unsigned long flags;                 // 状态标志位
    struct kvm_cpu_context host_ctxt;   // host的CPU上下文
};
</code></pre>
<p><strong>重要特性</strong>：</p>
<ul>
<li>Per-CPU数据结构，每个物理CPU一个实例</li>
<li>通过标志位管理各种硬件特性</li>
<li><code>host_ctxt</code>保存host的完整状态</li>
</ul>
<h3 id="7-kvm_s2_mmu-stage2映射"><a class="header" href="#7-kvm_s2_mmu-stage2映射">7. kvm_s2_mmu Stage2映射</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_host.h</code></p>
<pre><code class="language-c">struct kvm_s2_mmu {
	struct kvm_vmid vmid;
	phys_addr_t	pgd_phys;       // PGD 物理地址
	struct kvm_pgtable *pgt;    // Stage2 页表
	int __percpu *last_vcpu_ran;// 每个 CPU 最后运行的 VCPU
	struct kvm_arch *arch;      // 架构特定数据
};
</code></pre>
<p><strong>主要作用</strong>：</p>
<ul>
<li>管理guest的二级地址转换（Stage 2 Translation）</li>
<li>实现内存虚拟化，隔离guest物理内存</li>
<li>管理虚拟地址到物理地址的映射</li>
</ul>
<h3 id="8-kvm_pgtable-stage2页表"><a class="header" href="#8-kvm_pgtable-stage2页表">8. kvm_pgtable Stage2页表</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_pgtable.h</code></p>
<pre><code class="language-c">struct kvm_pgtable {
    u32                            ia_bits;        // IPA 地址位数
    u32                            start_level;    // 起始页表级别
    kvm_pte_t                      *pgd;           // PGD 页表根指针
    struct kvm_pgtable_mm_ops     *mm_ops;        // 内存操作回调
    struct kvm_s2_mmu              *mmu;           // 关联的 MMU
    enum kvm_pgtable_stage2_flags  flags;          // 标志位
    kvm_pgtable_force_pte_cb_t    force_pte_cb;   // 强制 PTE 回调
};
</code></pre>
<hr>
<p><em>参考文件：arch/arm64/kvm/arm.c, arch/arm64/kvm/hyp/</em>/switch.c, arch/arm64/kvm/hyp/entry.S</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../arm/ARM64_ABI.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="../kvm/nVHE.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../arm/ARM64_ABI.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="../kvm/nVHE.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-c2a407aa.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
