<!DOCTYPE HTML>
<html lang="zh" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-6b29ef5c.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-3c9db5cd.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>这个是一个用于记录学习资料的博客，使用mdbook把markdown渲染成静态网页，使用github Actions流水线部署到Github Pages。</p>
<p>mdbook是真正的简单好用，最喜欢的功能是在SUMMARY.md内创建目录，会自动创建文件夹，而且SUMMARY.md可以使用<code>//</code>注释掉不想发布的页面。</p>
<p>因此第一篇文章将分享如何mdbook部署笔记。</p>
<p>交流可以到该项目提<a href="https://github.com/errorcode7/errorcode7.github.io/issues">issue</a>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mdbook命令"><a class="header" href="#mdbook命令">mdbook命令</a></h1>
<p>mdbook的主要命令就是初始工程和启动服务。</p>
<h2 id="init"><a class="header" href="#init">init</a></h2>
<pre><code class="language-shell">&gt; mdbook init -h
mdbook.exe-init v0.4.21
Creates the boilerplate structure and files for a new book

USAGE:
    mdbook.exe init [OPTIONS] [dir]

ARGS:
    &lt;dir&gt;    Directory to create the book in
             (Defaults to the Current Directory when omitted)

OPTIONS:
        --force              Skips confirmation prompts
    -h, --help               Print help information
        --ignore &lt;ignore&gt;    Creates a VCS ignore file (i.e. .gitignore) [possible values: none,
                             git]
        --theme              Copies the default theme into your source folder
        --title &lt;title&gt;      Sets the book title
    -V, --version            Print version information
  
</code></pre>
<h2 id="serve"><a class="header" href="#serve">serve</a></h2>
<pre><code class="language-shell">&gt; mdbook serve -h
mdbook.exe-serve v0.4.21
Serves a book at http://localhost:3000, and rebuilds it on changes

USAGE:
    mdbook.exe serve [OPTIONS] [dir]

ARGS:
    &lt;dir&gt;    Root directory for the book
             (Defaults to the Current Directory when omitted)

OPTIONS:
    -d, --dest-dir &lt;dest-dir&gt;    Output directory for the book
                                 Relative paths are interpreted relative to the book's root
                                 directory.
                                 If omitted, mdBook uses build.build-dir from book.toml or defaults
                                 to `./book`.
    -h, --help                   Print help information
    -n, --hostname &lt;hostname&gt;    Hostname to listen on for HTTP connections [default: localhost]
    -o, --open                   Opens the compiled book in a web browser
    -p, --port &lt;port&gt;            Port to use for HTTP connections [default: 3000]
    -V, --version                Print version information
</code></pre>
<p>1.初始化工程</p>
<pre><code class="language-shell">mkdir docs &amp;&amp; cd docs
mdbook init . --title "my book"
</code></pre>
<p>2.启用服务,默认端口是3000，–open会自动打开默认浏览器。</p>
<pre><code class="language-shell">mdbook serve . --open
</code></pre>
<p>3.现在可以通过在编辑src下的SUMMARY.md中新增章节，新增条目后，会自动创建文件,同时更新网页目录。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="mdbook/pic/pic1.png">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">文件布局</div>

</center>
<p>serve自动将markdown渲染输出到book目录，因此<code>.gitignore</code>文件的book，表示忽略book目录内的修改，防止触发build。</p>
<blockquote>
<p>参考：https://rust-lang.github.io/mdBook/index.html</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="github-pages"><a class="header" href="#github-pages">github pages</a></h1>
<p><a href="https://pages.github.com/">github pages</a> 支持静态网页，我们需要把我们渲染后的mdbook上传到github pages仓库。虽然简单粗暴，但有几个完美主义者不能接受的缺点。</p>
<ul>
<li>手动build渲染生成的静态网页再push，diff肯定会很多，看起来不舒服。</li>
<li>本地修改的markdown丢失，通过静态网页恢复很麻烦。</li>
</ul>
<p>因此，我们需要CICD流水线帮助我们build &amp; deploy，我们只管提交md源代码即可。
github的CICD工具很多，当然肯定是他们自亲儿子Actions最好，点击仓库中的Actions选项就能看到流水线。</p>
<p>gitlab里叫pipelines，github叫workflows，我们只需要在当前mdbook工程的 <code>.github/workflows</code>下创建yaml格式的流水线控制文件即可。</p>
<pre><code class="language-shell">mkdir -p .github/workflows 
vim .github/workflows/gh-pages.yml
</code></pre>
<p>我们新建的<code>gh-pages.yml</code>内容：</p>
<pre><code class="language-yml">name: GitHub Pages Site Build and Deploy workflow
on:
  # 触发流水线的事件，推送或者合并
  push:
    branches:
      - main

  pull_request:
    branches:
      - main
jobs:
  build-and-deploy:
    # 使用构建镜像
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
    
    # clone代码，使用checkout这个action，不带@表示使用最新版本，官方建议带。
    steps:
      - name: Checkout
        uses: actions/checkout@v2
    # 构建代码，相当于使用别人做的mdbook docker
      - name: Build and Deploy
        uses: peaceiris/actions-mdbook@v1
        with:
          mdbook-version: 'latest'
    # 构建代码      
      - run: mdbook build

    # 部署静态页面
      - name: Deploy
        uses: peaceiris/actions-gh-pages@v3
        if: ${{ github.ref == 'refs/heads/main' }}
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: ./book
</code></pre>
<p>在提交代码之前需要：</p>
<p>1.创建ssh密钥对</p>
<p>密钥对生成在当前目录下，千万不要在工程目录下创建，否则不小心提交上去就悲剧了。</p>
<pre><code class="language-shell">cd #切换到用户目录去创建
git config --global user.name yourname
git config --global user.email yourname@gmail.com

ssh-keygen -t rsa -b 4096 -C "$(git config user.email)" -f gh-pages -N ""
</code></pre>
<p>2.github上创建项目并配置</p>
<ul>
<li>
<p>创建项目名称：your-github-name.github.io</p>
</li>
<li>
<p>仓库的Settings里的Deploy Keys项目添加key，<code>title</code>为<code>ACTIONS_DEPLOY_KEY</code>，<code>Key</code>填入公钥文件<code>gh-pages.pub</code>的内容，勾选<code>Allow write access</code>；</p>
<p>在Secrets下的Actions内添加Secrets，<code>Name</code>为<code>ACTIONS_DEPLOY_KEY</code>,<code>Secrets</code>填入私钥文件<code>gh-pages</code>的内容。</p>
</li>
</ul>
<p>3.推送本地项目</p>
<pre><code class="language-shell"># 初始化当前mdbook工程，并将本地项目的远端设置为新建的git仓库地址
git init . 
git add *
git commit -m "first commit"
git branch -M main
git remote add origin git@github.com:errorcode7/errorcode7.github.io.git
# push前，保证本地.ssh下的公钥已经添加到github账户Settings的SSH keys
git push -u origin main
</code></pre>
<p>4.检查部署页面</p>
<p>提交成功后点击仓库里的Actions，查看流水线构建情况。</p>
<p>提交代码后会触发构建流水线，生成的静态网页会被自动提交到<code>gh-pages</code>分支，触发静态网页部署的流水线，因此每次提交都有两个流水线,源码构建与page部署，其中<code>pages build and deployment</code>是部署到github.io的流水线。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="github/pic/actions.png">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">流水线</div>

</center>
<p><strong>注意</strong>：如果页面404，到项目的Settings-&gt;Pages下查看Pages站点的来源是那个分支，可以手动切换到<code>gh-pages</code>分支，会重新触发Action，要等部署完才生效。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="github/pic/page.png">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">page设置</div>

</center>
<p>当前<a href="http://errorcode7.github.io">pages</a>工程的仓库地址：<a href="https://github.com/errorcode7/errorcode7.github.io">https://github.com/errorcode7/errorcode7.github.io</a></p>
<blockquote>
<p>参考：https://github.com/marketplace/actions/mdbook-action</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="3d渲染基本概念"><a class="header" href="#3d渲染基本概念">3D渲染基本概念</a></h1>
<ul>
<li>顶点(vertex)，描述物体在三维坐标中的向量，一个三角面有三个点，每个顶点有一组三维坐标项链[x,y,z]，物体越复杂，构成的顶点则越多。物体除了顶点还有纹理坐标，法线，顶点色等数据组成，把这一组数据统称vertex buffer,存储数据的格式有很多种。</li>
<li>index buffer，物体的表面需要上色，三个顶点是构成一个面的最小单元，记录一组顶点下标的数组，叫做index buffer。当我们绘制多边形的时候，传入的是顶点的索引，而非索引数组，可提高代码效率。比如我们绘制四边形的时候，需要传入两个三角形的顶点，当我们用索引记录的时候，只需要传入包含6个顶点的索引的index buffer即可。</li>
<li>纹理(Texture)，自然界中重复出现的颜色叫做纹理，多种重复出现的纹理可以组合继续重复出现，构成更大的纹理，在二维平面中就是一张图片。顶点的纹理坐标记录着顶点在纹理二维平面中的坐标，3维空间中的顶点通过这个纹理坐标映射到在纹理数据中的坐标，使得每个单元都有对应的颜色。</li>
<li>光栅化(rasterization)，三角形在屏幕坐标中是由N个正方形像素构成，用颜色填充三角形覆盖范围内的像素的过程叫做光栅化。这个固定的步骤是可以固定计算单元实现，叫做rasterizer。在填充之前，需要将3D空间中的三角形变换为屏幕中的2D三角形。最终的颜色是由材质，纹理，光源等经过就算得出，类似函数y=ax1+bx2+cx3一样多个参数输出，控制最终的输出。(光栅化这个翻译，就不能信达雅吗？)</li>
<li>着色器(shader),shade本意是阴影，shader最初是用计算光照和阴影的，上色的过程本质就是一个计算的过程，每一个计算的函数也叫做一个shader。因此shader并不只是上色，只要有变换的地方都需要计算，变换千差万别，计算函数也千差万别，因此这部分是可编程的，所谓的shader编程本质就是函数编程。处理顶点的叫vertex shader，处理像素的叫pixel shader，不同的shader出现在流水线(管线)的不同阶段。</li>
<li>管线(pipline)，将原始数据，像工厂流水线一样，经过各种单元处理，最终生成可以显示输出的帧(framebuffer)对象。</li>
<li>surface，这是egl的概念，像是一个可以修改的图层或画布，对内管理着它拥有的framebuffer，对外(窗口)表示自己有显示能力，不同操作系统的窗口管理器产生的窗口都可以和surface绑定，让它提供显示能力，不用关心它一个还是多个buffer实现，它可以在屏幕内，也可在以屏幕外。结合Wayland的描述，它可以和背景绑定，窗口绑定，光标绑定。OpenGL只负责将数据渲染成帧，并不负责输出到屏幕。输出屏幕的工作叫做送显示，属于窗口管理器的活儿。早年显卡没有3D渲染加速时候的主要工作就是送显，这个部件叫做<code>Display Controller</code>，kms驱动就是为他服务。操作系统的核心就是管理硬件，抽象成资源，被软件复用，多个应用程序都要输出则需要对显卡复用，首先驱动层面就要支持，其次系统层面要统一管理。渲染产生的帧通过surface被窗口记录，窗口管理器将不同窗口进程的记录的帧通知合成器统一合成，合成器把背景，多个窗口，光标交给硬件合成为一帧，然后送显部件送给显示器显示。全屏游戏独占屏幕，应用显示的帧几乎就是最终送显的帧，手机app这类占用大部分屏幕且状态栏基本没有变化的场景，合成的成本很低。</li>
</ul>
<p>OpenGL ES3 管线流水线中，API箭头表示可以输入的部分。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://pic3.zhimg.com/80/v2-05c0d0ad1e65ff4fbedee0b4d8f49316_720w.webp">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">OpenGL ES3 管线图</div>

</center> 
<p>vertex shader 实现代码</p>
<pre><code class="language-c">#version 300 es   // OpenGL ES版本信息
uniform mat4 u_mvpMatrix;  // 同一变量u_mvpMatrix，它存储组合的模型视图和投影矩阵。

// 描述顶点着色器的输入
in vec4 a_postion; // 输入顶点位置属性
in vec4 a_color; // 输入顶点颜色属性

out vec4 v_color; // 存储描述每个顶点颜色的顶点着色器输出

void main(){ // 主函数
	v_color = a_color; // 读入顶点属性输入a_color，并将其写入顶点输出颜色v_color
	gl_Position = u_mvpMatrix * a_postion // gl_Position是自动生成的，将变换后的顶点位置写入gl_Position输出
}
</code></pre>
<p>shader的本质就是y=ax1+bx2+cx3这样的矩阵计算，因此，输出入包含变和不变量两个部分，以u_mvpMatrix代表的是[a,b,c]这样的不变部分；a_postion，a_color这类顶点数据则代表做x1,x2这类变化的部分。</p>
<blockquote>
<p>https://www.bilibili.com/video/BV1P44y1V7bu/ 《上帝视角看GPU（1）：图形流水线基础》
https://vulkan-tutorial.com/Vertex_buffers/Vertex_input_description 《vulkan教程》
https://blog.csdn.net/xzben/article/details/124107260 《OpenGL 之Texture》
https://zhuanlan.zhihu.com/p/381327745 《【Learn OpenGL笔记】纹理(Texture)》
https://zhuanlan.zhihu.com/p/144332091 《计算机图形学七：纹理映射(Texture Mapping)及Mipmap技术》
https://www.intel.com/content/dam/develop/external/us/en/documents/the-architecture-of-intel-processor-graphics-gen11-r1new.pdf 《Intel核显Display Controller》</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="x11"><a class="header" href="#x11">x11</a></h1>
<p>x11是C/S模型,每个主机可以启动多个xserver作为服务器，每个服务器开启一个端口，供客户端连接，每个服务器可以有多个screen(显示器)，因此服务地址的格式为<code>DISPLAY=host:port.screen_number</code>,由于默认端口为6000起步，真实tcp/ip端口为<code>6000+port</code>。</p>
<p>每个screen可以上可以创建多个窗口。</p>
<h2 id="xlib"><a class="header" href="#xlib">xlib</a></h2>
<p>xlib是协议的c语言接口。</p>
<h3 id="graphicscontext"><a class="header" href="#graphicscontext">GraphicsContext</a></h3>
<p>绘图操作需要控制数据，通过数据结构保存这些复杂参数，传递给Server。</p>
<h2 id="xcb"><a class="header" href="#xcb">xcb</a></h2>
<p>X协议的C语言绑定，相比xlib，占用空间小，延迟低，多线程，可扩展等特性。</p>
<blockquote>
<p>https://www.x.org/wiki/guide/xlib-and-xcb/
https://www.x.org/releases/current/doc/libxcb/tutorial/index.html</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arm-abi"><a href="#arm-abi" class="header">arm ABI</a></h1>
<h2 id="调用约定"><a class="header" href="#调用约定">调用约定</a></h2>
<p><strong>ARM64 ABI</strong>（应用程序二进制接口）中规定了在函数调用过程中，哪些寄存器的值需要由<strong>调用方</strong>（caller）负责保存，哪些由<strong>被调用方</strong>（callee）负责保存。</p>
<h2 id="arm64-中的寄存器分类"><a class="header" href="#arm64-中的寄存器分类">ARM64 中的寄存器分类</a></h2>
<p>AAPCS64 ABI</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>寄存器</th><th>类型</th><th>别名</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td><strong>x0 – x7</strong></td><td><strong>caller-saved</strong></td><td>参数 / 返回值</td><td>用于传递前8个参数；x0/x1 也用于返回值</td></tr>
<tr><td>x8</td><td>caller-saved</td><td>间接结果</td><td>用于某些系统调用或大返回值</td></tr>
<tr><td>x9 – x15</td><td>caller-saved</td><td>临时寄存器</td><td>callee 可自由使用</td></tr>
<tr><td><strong>x16 – x17</strong></td><td>caller-saved</td><td>IP0/IP1</td><td>用于跳转、链接器内部使用</td></tr>
<tr><td><strong>x18</strong></td><td>特殊</td><td>平台寄存器</td><td>通常保留给平台（如 TLS）</td></tr>
<tr><td><strong>x19 – x29</strong></td><td><strong>callee-saved</strong></td><td>通用寄存器</td><td>callee 若使用，必须保存并恢复</td></tr>
<tr><td>x30</td><td>callee-saved（部分）</td><td><strong>lr</strong>（链接寄存器）</td><td>存放返回地址，通常需保存</td></tr>
</tbody>
</table>
</div>
<pre><code class="language-c">// caller 函数
long caller(long a, long b) {
    long temp = a + b;          // 假设 temp 存在 x0
    long result = callee(a);    // 调用 callee
    return temp + result;       // ← 这里仍要用 temp（原 x0 的值）
}
// callee 函数
long callee(long x) {
    return x * 2;               // 编译器可能用 x0 存放 x 和返回值
}
</code></pre>
<p>编译器生成的汇编（简化）：</p>
<pre><code class="language-asm">caller:
    add x0, x0, x1        // temp = a + b → 存在 x0
    stp x0, x1, [sp, #-16]!   // ← 保存 x0（temp）！因为 callee 会覆盖它
    bl callee             // 调用 callee（callee 会用 x0 存参数和返回值）
    ldp x2, x1, [sp], #16     // 恢复 temp 到 x2
    add x0, x2, x0        // return temp + result
    ret

callee:
    lsl x0, x0, #1        // x0 = x * 2
    ret                   // 直接返回，不恢复 x0（因为它是 caller-saved）
</code></pre>
<h2 id="设计目的"><a class="header" href="#设计目的">设计目的</a></h2>
<p>x0-x7作为参数寄存器，要一层一层的传递给callee，如果在caller做了修改，直接作为参数就传递进callee去了，他们经常需要被传递和修改，就像一个context或者全局变量一样，穿梭在各种函数之间，尤其是x0，x1这种既作为参数又作为返回值的寄存器，使用后不管是常态。</p>
<p>如果某些值需要保留生命周期，留在当前的caller里继续使用，向局部变量那样，则压栈，或者分配到x19–x28（callee-saved）,arm不是像x86那样一开始就开辟栈来保存局部变量。压栈和放到寄存器肯定是优先使用寄存器，当寄存器不够用的时候，才考虑压栈。</p>
<p>caller其实不知道哪些当前使用过的寄存器后续会不会被使用，决定要不要压栈是编译器的事，压栈属于编译器分析代码后的决定。比如一个变量放在x2里被操作，编译器编译过程中把他压栈，后续再使用变量的时候，编译器可能把它恢复到x3里倍操作。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="arm-kvm上下文切换机制分析"><a class="header" href="#arm-kvm上下文切换机制分析">ARM KVM上下文切换机制分析</a></h1>
<hr>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>本文档深入分析ARM架构中KVM（Kernel-based Virtual Machine）的上下文切换机制，重点解析<code>__kvm_vcpu_run_vhe</code>函数的工作原理和上下文切换的具体实现。本文需要有一定的知识，如中断、系统调用、x86虚拟化、arm异常级别，虚拟地址翻译等。</p>
<h3 id="关键概念"><a class="header" href="#关键概念">关键概念</a></h3>
<ul>
<li><strong>VHE (Virtualization Host Extension)</strong>：ARMv8.1引入的虚拟化扩展，允许hypervisor在EL2运行</li>
<li><strong>Non-VHE</strong>：传统虚拟化模式，hypervisor在EL1，依赖EL2进行虚拟化操作</li>
<li><strong>上下文切换</strong>：在host、guest和hypervisor之间切换执行状态的过程</li>
<li><strong>阶段2转换</strong>：guest虚拟地址到物理地址的地址转换</li>
</ul>
<h3 id="寄存器分类"><a class="header" href="#寄存器分类">寄存器分类</a></h3>
<p>在了解上下文切换之前，我们必须先了解寄存器的分类。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>类别</th><th>核心作用</th><th>典型场景</th><th>是否需上下文切换时保存？</th></tr>
</thead>
<tbody>
<tr><td><strong>执行上下文寄存器</strong></td><td>运行程序的“工作台”</td><td>函数调用、变量存储</td><td>✅ 必须（Host/Guest 切换）</td></tr>
<tr><td><strong>系统控制寄存器</strong></td><td>配置 CPU“工作模式”</td><td>开启MMU、设置页表、虚拟化陷阱</td><td>✅ Guest 独有，Host/Guest 切换时保存</td></tr>
<tr><td><strong>异常状态寄存器</strong></td><td>记录“出事时的情况”</td><td>缺页处理、未定义指令捕获</td><td>❌ 异常处理完即用完，不长期保存</td></tr>
</tbody>
</table>
</div>
<h4 id="执行上下文寄存器execution-context-registers"><a class="header" href="#执行上下文寄存器execution-context-registers">执行上下文寄存器（Execution Context Registers）</a></h4>
<p>作用：直接参与程序的指令执行与数据运算，是“代码运行时的现场”。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>子类</th><th>寄存器示例</th><th>说明</th></tr>
</thead>
<tbody>
<tr><td>通用寄存器</td><td><code>x0–x30</code></td><td>存放操作数、地址、函数参数/返回值</td></tr>
<tr><td>程序计数器</td><td>PC（隐式）</td><td>指向下一条要执行的指令</td></tr>
<tr><td>栈指针</td><td><code>SP_EL0/1/2</code></td><td>指向当前栈顶，用于函数调用/局部变量</td></tr>
<tr><td>链接寄存器</td><td><code>x30</code> / <code>LR_ELx</code></td><td>保存函数返回地址</td></tr>
</tbody>
</table>
</div>
<ul>
<li>被编译器和 ABI 直接使用。</li>
<li>用户态和内核态都大量使用。</li>
<li>上下文切换（如进程调度、VM-Exit）时<strong>必须完整保存/恢复</strong>。</li>
</ul>
<h4 id="统控制寄存器system-control-registers"><a class="header" href="#统控制寄存器system-control-registers">统控制寄存器（System Control Registers）</a></h4>
<p>作用：配置 CPU 的行为模式，决定“如何执行”而非“执行什么”。它的核心特点是<strong>控制</strong>。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>功能域</th><th>寄存器示例</th><th>控制内容</th></tr>
</thead>
<tbody>
<tr><td>内存管理</td><td><code>SCTLR_EL1</code>, <code>TTBR0_EL1</code>, <code>TCR_EL1</code></td><td>MMU 开关、页表基址、地址空间布局</td></tr>
<tr><td>虚拟化</td><td><code>HCR_EL2</code>, <code>VTTBR_EL2</code></td><td>是否启用 Stage-2 转换、哪些操作 trap 到 EL2</td></tr>
<tr><td>中断/异常</td><td><code>DAIF</code>（PSTATE）、<code>ICC_SRE_EL1</code></td><td>屏蔽 IRQ/FIQ/SError、中断路由</td></tr>
<tr><td>安全扩展</td><td><code>SCR_EL3</code></td><td>EL2 是否可用、Secure/Non-secure 切换</td></tr>
<tr><td>性能/调试</td><td><code>PMCR_EL0</code>, <code>OSLAR_EL1</code></td><td>性能计数器使能、调试锁</td></tr>
</tbody>
</table>
</div>
<ul>
<li>通常只在特权级（EL1/EL2/EL3）可写，一般由<strong>操作系统和内核模块</strong>负责修改。</li>
<li>修改后影响后续所有指令的执行环境。</li>
<li>很多寄存器的某一位是“控制位”，另一些位是“状态位”。</li>
</ul>
<h4 id="异常与状态保存寄存器exception--state-saving-registers"><a class="header" href="#异常与状态保存寄存器exception--state-saving-registers">异常与状态保存寄存器（Exception &amp; State-Saving Registers）</a></h4>
<p>作用：在异常发生时自动保存关键状态，用于后续恢复或诊断。它们不用于主动控制 CPU，而是被动反映异常瞬间的状态，影响操作系统的执行逻辑。</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>寄存器</th><th>作用</th></tr>
</thead>
<tbody>
<tr><td><code>ELR_ELx</code></td><td>保存异常发生时的 <strong>PC（返回地址）</strong></td></tr>
<tr><td><code>SPSR_ELx</code></td><td>保存异常发生时的 <strong>PSTATE（含 DAIF、EL、NZCV 等）</strong></td></tr>
<tr><td><code>ESR_ELx</code></td><td>记录<strong>异常原因</strong>（如缺页类型、未定义指令）</td></tr>
<tr><td><code>FAR_ELx</code></td><td>记录<strong>引发异常的虚拟地址</strong></td></tr>
</tbody>
</table>
</div>
<ul>
<li>由硬件在异常入口自动填充。</li>
<li>主要供异常处理程序（如内核）读取，用于决定如何响应。</li>
<li>通常不可由软件直接用于控制 CPU 行为（只读或写无效）。</li>
</ul>
<h3 id="虚拟化常见寄存器"><a class="header" href="#虚拟化常见寄存器">虚拟化常见寄存器</a></h3>
<p><strong>虚拟化控制寄存器</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>寄存器名</th><th>全称</th><th>功能说明</th><th>关键作用</th></tr>
</thead>
<tbody>
<tr><td><strong>HCR_EL2</strong></td><td>Hypervisor Configuration Register</td><td>控制虚拟化行为的各个方面</td><td>通过位设置决定哪些操作（如内存访问、指令执行）会陷阱（trap）到 EL2</td></tr>
<tr><td><strong>VTTBR_EL2</strong></td><td>Virtualization Translation Table Base Register</td><td>指向 OS 的二级页表</td><td>包含 VMID（虚拟机标识符）和 Stage-2 页表的物理基地址</td></tr>
<tr><td><strong>VTCR_EL2</strong></td><td>Virtualization Translation Control Register</td><td>控制二级地址转换（Stage-2 translation）参数</td><td>定义 IPA（Intermediate Physical Address）空间大小、页表粒度（如4KB/16KB/64KB）等</td></tr>
<tr><td><strong>TTBR0/1_EL2</strong></td><td>Translation Table Base Register</td><td>指向 OS 的一级页表</td><td>供mmu实现虚拟地址到物理地址/中间地址的转换</td></tr>
</tbody>
</table>
</div>
<hr>
<p><strong>状态与异常处理寄存器</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>寄存器名</th><th>全称</th><th>功能说明</th><th>关键作用</th></tr>
</thead>
<tbody>
<tr><td><strong>ESR_EL2</strong></td><td>Exception Syndrome Register</td><td>记录异常的详细信息</td><td>提供异常类型、指令信息等，用于 EL2 异常处理和调试</td></tr>
<tr><td><strong>FAR_EL2</strong></td><td>Fault Address Register</td><td>记录引发数据/指令访问错误的虚拟地址</td><td>用于页错误（Page Fault）诊断，指出出错的虚拟地址</td></tr>
<tr><td><strong>HPFAR_EL2</strong></td><td>Hypervisor IPA Fault Address Register</td><td>记录 Guest 物理地址（IPA）错误</td><td>在 Stage-2 地址转换失败时，提供出错的 IPA 高位（配合 FAR_EL2 使用）</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="总体架构"><a class="header" href="#总体架构">总体架构</a></h2>
<p>先来一张总体流程图，大概描述整个kvm用户空间和内核空间是如何协同工作的。</p>
<center>
    <br>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="kvm/pic/arm-kvm.jpg" width="80%">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">arm-vhe-kvm</div>

</center>
<ul>
<li>
<p>用户空间代码调用ioctl系统调用，触发内核kvm模块实现的函数调用，在内核的hypervisor发生上下文切换，也就是将host运行的指令保存，载入guest的指令(上下文)到CPU，在<code>__guest_enter</code>调用eret，进入guest的EL1级别继续执行PC寄存器的指令。（host el0 -&gt; host el2 -&gt; guest el1 ）</p>
</li>
<li>
<p>当CPU执行到敏感指令的时候，触发异常，退出guest状态，陷入到L2级别hypervisor的中断向量，中断向量很快就跳转到<code> __guest_exit</code>，<code>__guest_exit</code> ret后，CPU回到hypervisor上下文，经过fixup_guest_exit简单的处理，如果成功，则仅需切回guest。</p>
<p>如果失败，则需要继续回到host，在host内handle_exit处理捕获到的异常，当处理成功，则继续在切换到guest处理，当处理失败，则错误返回给用户空间处理，用户空间处理完成后继续调用ioctl进入内核，发生上下文切换，执行guest代码。</p>
</li>
</ul>
<p>Q：什么是用户空间代码？作用是什么？</p>
<p>A：qemu这类用户态程序。</p>
<ul>
<li>
<p>管理VM和VCPU的生命周期。</p>
</li>
<li>
<p>设备模拟和环境准备，如磁盘，内核文件，固件等；在内核无法处理异常，放到用户空间处理，比如IO，关机，信号、中断注入等。</p>
</li>
<li>
<p>分配虚拟机内存。</p>
</li>
</ul>
<p>Q：什么是上下文切换？如何切换？</p>
<p>A：上下文就是CPU寄存器状态。在x86环境中，有一个数据结构叫做VMCS，两个对象记录host和guest的上下文；在arm环境中，记录上下文用kvm_cpu_context，一个是kvm对象引用的kvm_cpu_context记录guest的上下文，通过perCPU上定义的kvm_cpu_context记录host的上下文。第一次运行的时候，要先准备好guest的上下文。整个原理是我们的核心分析过程，后面将详细描述。</p>
<p>Q：什么是guest和host？</p>
<p>A：host是宿主机执行指令的状态，guest是虚拟机执行指令的状态。当从host切换到guest执行代码的时候，需要在host执行切换相关的代码，设置CPU工作模式，CPU进入guest的工作状态，保存host的寄存器到内存，载入guest的寄存器值到CPU，然后特定的指令来模拟恢复到之前执行状态。guest状态切换到host，反之亦然。</p>
<p>在x86中，host就是vmx root mode，不过没必要去记root和none-root，只需要记住host状态和guest状态。</p>
<p>Q：什么是敏感指令？</p>
<p>A：敏感指令就是CPU虚拟化里定义的，需要特殊关注处理的指令。arm则的所有敏感指令都是特权指令，因此只有el1的状态的guest才能陷入el2。x86的敏感指令既有特权指令也有非特权指令，<strong>不必刻意去区分是否拥有特权</strong>，只需要知道他们特殊罢了。</p>
<p>CPU有各种工作模式，当你不开启虚拟化，那么就不会关注敏感指令，当开启虚拟，并通过设置特定寄存器告诉CPU要关注某些敏感指令，一旦CPU处于guest状态，流水线上发现了敏感指令，则触发中断，在中断里模拟指令的实现。</p>
<p>你可以想象一下马里奥踩到特殊地砖，进入到地下执行任务，执行完了后再次回到地上的流程，去地下就是回到host，模拟执行特殊指令。进入到host状态，这个过程叫做VM-exit，进入到guest状态的过程叫做VM-entry。</p>
<p>Q：CPU如何知道当前运行的是guest，需要去拦截敏感指令？</p>
<p>A：CPU寄存器分为控制CPU工作模式的控制寄存器，状态寄存器，执行上下文寄存器这几类。在CPU切换到guest代码之前，host代码会去操作控制寄存器，让CPU以另外一种工作模式运行，敏感指令就被监控，一旦触发就陷入异常，回到host模拟。</p>
<h2 id="关键函数"><a class="header" href="#关键函数">关键函数</a></h2>
<p><strong>关键流程</strong></p>
<pre><code class="language-txt">ioctl(vcpu_fd, KVM_RUN, NULL);//qemu
  ↓
kvm_vcpu_ioctl()
    kvm_arch_vcpu_ioctl_run()
        kvm_arm_vcpu_enter_exit()
            kvm_call_hyp_ret(__kvm_vcpu_run, vcpu)
            ├─ VHE模式: __kvm_vcpu_run_vhe() 
            └─ 非VHE模式: __kvm_vcpu_run()
                __guest_enter() (汇编实现)
                   eret (异常返回指令)
</code></pre>
<h3 id="1--用户空间代码"><a class="header" href="#1--用户空间代码">1.  用户空间代码</a></h3>
<p>来源：<a href="https://www.cnblogs.com/LoyenWang/p/13796537.html">Linux虚拟化KVM-Qemu分析（四）之CPU虚拟化（2）</a>，这份代码模拟qemu的基本工作原理：</p>
<ul>
<li>打开kvm对象，根据kvm对象创建vm对象，根据vm对象创建VCPU。</li>
<li>分配用户空间地址，将可执行二进制映射到分配的内存。</li>
<li>KVM_SET_USER_MEMORY_REGION系统调用，将分配的用户空间地址作为虚拟机的物理内存地址。</li>
<li>使用kvm实现的mmap函数，将VCPU内记录运行状态的内存共享到用户空间，方便读取从内核返回到用户空间的原因。</li>
<li>设置CPU最初始化的寻址方式，从物理内存的指定位置读取内存。(这是x86的设置方式)。</li>
<li>使用KVM_RUN启动VCPU，当系统调用返回的时候读取内核返回的原因，然后在用户空间处理，处理后继续运行VCPU。</li>
</ul>
<pre><code class="language-c">#define KVM_DEV     "/dev/kvm"
#define TINY_KERNEL_FILE    "./tiny_kernel.bin"
#define PAGE_SIZE  0x1000
int main(void)
{
    int kvm_fd;
    int vm_fd;
    int vcpu_fd;
    int tiny_kernel_fd;
    int ret;
    int mmap_size;
    
    struct kvm_sregs sregs;
    struct kvm_regs regs;
    struct kvm_userspace_memory_region mem;
    struct kvm_run *kvm_run;
    void *userspace_addr;

    /*打开kvm设备，返回代表kvm的套接字*/
    kvm_fd = open(KVM_DEV, O_RDWR);
    assert(kvm_fd &gt; 0);

    /*创建VM对象 */
    vm_fd = ioctl(kvm_fd, KVM_CREATE_VM, 0);
    assert(vm_fd &gt;= 0);

    /*根据vm对象创建vcpu对象*/
    vcpu_fd = ioctl(vm_fd, KVM_CREATE_VCPU, 0);//kvm_vm_ioctl_create_vcpu在内核创建vcpu对象
    assert(vcpu_fd &gt;= 0);

    /* map 4K into memory */
    userspace_addr = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    assert(userspace_addr &gt; 0);
    /* 打开虚拟机将运行的二进制 */

    tiny_kernel_fd = open(TINY_KERNEL_FILE, O_RDONLY);
    assert(tiny_kernel_fd &gt; 0);    
    /* 文件映射到内存 */
    ret = read(tiny_kernel_fd, userspace_addr, PAGE_SIZE);
    assert(ret &gt;= 0);
	/*将二进制映射到内存*/
    
    /*将当前进程分配的虚拟内存，作为虚拟机的物理内存*/
    mem.slot = 0;
    mem.flags = 0;
    mem.guest_phys_addr = 0;
    mem.memory_size = PAGE_SIZE;
    mem.userspace_addr = (unsigned long)userspace_addr;
    
    /*KVM_SET_USER_MEMORY_REGION将虚拟内存作为vm对象的内存，此时VCPU读取物理内存*/
    ret = ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;mem);
    assert(ret &gt;= 0);

    /* KVM_GET_VCPU_MMAP_SIZE获取kvm_run地址，这个结构体用于存储运行kvm运行状态，
    	用户空间代码通过这个结构体获取kvm的运行状态
    */
    mmap_size = ioctl(kvm_fd, KVM_GET_VCPU_MMAP_SIZE, NULL);
    assert(mmap_size &gt;= 0);
    //这里很有意思，将vcpu的内存映射到用户空间。
    kvm_run = (struct kvm_run *)mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpu_fd, 0);
    assert(kvm_run &gt;= 0);

    /*sregs包含了x86架构的系统寄存器和段寄存器状态，这些寄存器控制着CPU的核心操作模式
    tiny_kernel.bin预期被加载到物理地址0，并且从16位实模式开始执行。
    */
    ret = ioctl(vcpu_fd, KVM_GET_SREGS, &amp;sregs);
    assert(ret &gt;= 0);
    sregs.cs.base = 0;
    sregs.cs.selector = 0;
    
    ret = ioctl(vcpu_fd, KVM_SET_SREGS, &amp;sregs);
    memset(&amp;regs, 0, sizeof(struct kvm_regs));
    regs.rip = 0;
    ret = ioctl(vcpu_fd, KVM_SET_REGS, &amp;regs);
    assert(ret &gt;= 0);

    /* 指定一个cpu运行，一个CPU对应一个kvm_run结构体 */
    while (1) {
        ret = ioctl(vcpu_fd, KVM_RUN, NULL);ioctl(vcpu_fd, KVM_RUN, NULL);
        assert(ret &gt;= 0);

        switch(kvm_run-&gt;exit_reason) {
            case KVM_EXIT_HLT:
                printf("----KVM EXIT HLT----\n");
                close(kvm_fd);
                close(tiny_kernel_fd);
                return 0;
            case KVM_EXIT_IO:
                putchar(*(((char *)kvm_run) + kvm_run-&gt;io.data_offset));
                break;
            default:
                printf("Unknow exit reason: %d\n", kvm_run-&gt;exit_reason);
                break;
        }
    }

    return 0;
}
</code></pre>
<h3 id="2-kvm驱动实现"><a class="header" href="#2-kvm驱动实现">2. kvm驱动实现</a></h3>
<h4 id="kvm_run系统调用入口"><a class="header" href="#kvm_run系统调用入口">KVM_RUN系统调用入口</a></h4>
<p>ioctl(vcpu_fd, KVM_RUN, NULL)实际调用的对应在内核中的处理逻辑如下：</p>
<pre><code class="language-c">static long kvm_vcpu_ioctl(struct file *filp,
			   unsigned int ioctl, unsigned long arg)
{
	struct kvm_vcpu *vcpu = filp-&gt;private_data;//从套接字对应的filp对象中获取vcpu对象。
    ....
	switch (ioctl) {
	case KVM_RUN: {
        ....
		r = kvm_arch_vcpu_ioctl_run(vcpu);//关键入口，返回整数r,错误原因
		....
		break;
	}
...
}     

</code></pre>
<p>在host处理异常，在kvm_arch_vcpu_ioctl_run内，都还属于host kernel的范围，kvm_arm_vcpu_enter_exit这是在准备进入到hypervisor。handle_exit处理异常，处理成功则继续循环，处理失败则返回，最终回到用户空间。</p>
<pre><code class="language-c">int kvm_arch_vcpu_ioctl_run(struct kvm_vcpu *vcpu)
{
	struct kvm_run *run = vcpu-&gt;run;
	int ret;

	if (run-&gt;exit_reason == KVM_EXIT_MMIO) {
		ret = kvm_handle_mmio_return(vcpu);
		if (ret)
			return ret;
	}

	vcpu_load(vcpu);

	if (run-&gt;immediate_exit) {
		ret = -EINTR;
		goto out;
	}

	kvm_sigset_activate(vcpu);

	ret = 1;
	run-&gt;exit_reason = KVM_EXIT_UNKNOWN;
	run-&gt;flags = 0;
	while (ret &gt; 0) {
        ...
		ret = kvm_arm_vcpu_enter_exit(vcpu);
        ...
		ret = handle_exit(vcpu, ret);
	}
    ...
	return ret;
}

static int noinstr kvm_arm_vcpu_enter_exit(struct kvm_vcpu *vcpu)
{
	int ret;

	guest_state_enter_irqoff();
	ret = kvm_call_hyp_ret(__kvm_vcpu_run, vcpu);//封装
	guest_state_exit_irqoff();

	return ret;
}
</code></pre>
<h4 id="vhe模式"><a class="header" href="#vhe模式">VHE模式</a></h4>
<h5 id="nvhe"><a class="header" href="#nvhe">nVHE</a></h5>
<p>kvm_call_hyp_ret算是host和hypervisor的分界线，这里根据 has_vhe()判断是否启用了VHE，决定使用哪种调用。</p>
<ul>
<li>在非VHE模式模式中，<strong>kvm_call_hyp_ret()</strong> 宏走kvm_call_hyp_nvhe路径，调用<strong>arm_smccc_1_1_hvc</strong>，会触发一个 HVC 指令，把当前正在运行在内核中EL1状态的 CPU陷入 EL2，才能执行host和guest的上下文切换，进入到guest的。也就是说，在内核中的<strong>kvm模块需要再次陷入</strong>到更高的异常级别才能操作硬件资源。</li>
<li>VHE模式中，Linux 内核本身就在 EL2 运行，所以直接调用 f() 同样是在 EL2 中，不用陷入到EL2。</li>
</ul>
<pre><code class="language-c">#ifndef __KVM_NVHE_HYPERVISOR__
#define kvm_call_hyp_nvhe(f, ...)						\
	({								\
		struct arm_smccc_res res;				\
									\
		arm_smccc_1_1_hvc(KVM_HOST_SMCCC_FUNC(f),		\
				  ##__VA_ARGS__, &amp;res);			\
		WARN_ON(res.a0 != SMCCC_RET_SUCCESS);			\
									\
		res.a1;							\
	})

/*
 * The isb() below is there to guarantee the same behaviour on VHE as on !VHE,
 * where the eret to EL1 acts as a context synchronization event.
 */
#define kvm_call_hyp(f, ...)						\
	do {								\
		if (has_vhe()) {					\
			f(__VA_ARGS__);					\
			isb();						\
		} else {						\
			kvm_call_hyp_nvhe(f, ##__VA_ARGS__);		\
		}							\
	} while(0)

#define kvm_call_hyp_ret(f, ...)					\
	({								\
		typeof(f(__VA_ARGS__)) ret;				\
									\
		if (has_vhe()) {					\
			ret = f(__VA_ARGS__);				\
		} else {						\
			ret = kvm_call_hyp_nvhe(f, ##__VA_ARGS__);	\
		}							\
									\
		ret;							\
	})
#else /* __KVM_NVHE_HYPERVISOR__ */
#define kvm_call_hyp(f, ...) f(__VA_ARGS__)
#define kvm_call_hyp_ret(f, ...) f(__VA_ARGS__)
#define kvm_call_hyp_nvhe(f, ...) f(__VA_ARGS__)
</code></pre>
<p>从这里可以看出nVHE模式， kvm_call_hyp_ret是el1到el2的标志。将hyp和host做了区分。</p>
<pre><code class="language-c">kvm_arch_vcpu_ioctl_run()
{
    while (ret &gt; 0) {
        ...
    	ret = kvm_arm_vcpu_enter_exit(vcpu);//这里进入,内部就是kvm_call_hyp_ret提权操作
        ...
    	ret = handle_exit(vcpu, ret);//host处理，处理不了就再返回
    }
}
</code></pre>
<p>在之前的arm规范中，严格区分了内核代码运行在EL1和hypervisor运行在EL2，也就是nVHE模式的kvm实现。</p>
<p>进入guest：</p>
<ul>
<li>当用户启动虚拟机的时候，要先系统调用进入内核(Host EL1)，内核再<strong>通过HVC 指令进入EL2</strong>级别的执行hypervisor代码，hypervisor进入到guest代码运行。</li>
</ul>
<p>退出guest：</p>
<ul>
<li>同样，guest代码运行的时候访问io资源，guest处于el1的状态，执行的敏感指令被拦截，陷入到EL2级里的hypervisor执行，在EL2内的hypervisor只能处理简单的异常，大部分异常需要继续返回。再从EL2返回到EL1的内核态的kvm模块处理，在EL1内核态再返回给用户。</li>
<li>用户态处理完后还要通过系统调用，如一开始运行那样进入guest执行。</li>
</ul>
<h5 id="vhe"><a class="header" href="#vhe">VHE</a></h5>
<p>为了减少这么多步骤的异常级切换，直接让hypervisor和内核工作在一个异常级别即可。ARMv8.1 通过以下机制，使得内核运行在 EL2 ：
HCR_EL2.E2H = 1（Enable EL2 Host）,    当此位为 1 时，EL2 的行为被“重塑”：</p>
<ul>
<li>
<p>访问 TTBR0_EL1 实际操作的是 TTBR0_EL2，也就是说，之前的内核代码不用修改访问寄存器的指令，就可以访问TTBR0_EL2(页表寄存器)。</p>
</li>
<li>
<p>SPSR_EL1、ELR_EL1 等寄存器在 EL2 中可用</p>
</li>
<li>
<p>系统调用（SVC）可以从 EL0 直接陷入 EL2（而非 EL1）</p>
<p>效果：相当于取消host EL1，直接让内核工作在EL2。</p>
</li>
</ul>
<p>HCR_EL2.TGE = 1（Trap General Exceptions）</p>
<ul>
<li>配合 E2H，使 EL0 的异常（如 SVC、IRQ）直接路由到 EL2。</li>
</ul>
<p>Stage-1 页表支持</p>
<ul>
<li>
<p>即使在 EL2，也可以使用自己的 Stage-1 页表（通过 TTBR0_EL2 / TTBR1_EL2），实现虚拟地址空间。</p>
</li>
<li>
<p>但 Linux 内核严重依赖虚拟内存（<code>vmalloc</code>, <code>slab</code>, 用户态映射等）。</p>
</li>
</ul>
<div class="table-wrapper">
<table>
<thead>
<tr><th>机制</th><th>解决的问题</th><th>实现效果</th></tr>
</thead>
<tbody>
<tr><td><strong><code>E2H=1</code></strong></td><td>EL2 无法使用 EL1 寄存器</td><td><strong>寄存器别名映射</strong>，Linux 代码无需修改</td></tr>
<tr><td><strong><code>TGE=1</code></strong></td><td>EL0 异常无法路由到 EL2</td><td><strong>异常直接陷入 EL2</strong>，Host 能处理 syscall/IRQ</td></tr>
<tr><td><strong>Stage-1 in EL2</strong></td><td>EL2 无虚拟内存支持</td><td><strong>完整虚拟地址空间</strong>，支持现代 OS 内存管理</td></tr>
</tbody>
</table>
</div>
<p>最终，本质上kvm和内核都工作在EL2，host上只有EL0和EL2，根x86差不多。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="kvm/pic/nvhe_vs_vhe.png" width="50%">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">nvhe-vs-vhe</div>

</center>
<hr>
<h4 id="arm-kvm上下文切换实现"><a class="header" href="#arm-kvm上下文切换实现">ARM KVM上下文切换实现</a></h4>
<h4 id="__kvm_vcpu_run_vhe函数"><a class="header" href="#__kvm_vcpu_run_vhe函数">__kvm_vcpu_run_vhe函数</a></h4>
<p>在寄存器分类中，我们知道分为执行上下文，系统控制，异常状态这几类，所以进入上下文切换之前，需要：</p>
<ul>
<li>保存一些host的CPU运行状态</li>
<li>设置CPU进入虚拟化执行的工作模式</li>
<li>恢复恢复guest的CPU运行状态，有了运行状态，guest在el1的系统就有了运行逻辑的参考依据，一旦切换执行上下文成功，比如栈寄存器和PC寄存器就位，马上就可以开始有条不紊的工作。</li>
</ul>
<p>arm PC寄存器不能直接填入将指令的地址，需要将地址放入ELR_ELx，当执行 <code>eret</code> 的时候，ELR_ELx的值被自动弹入到PC，SPSR_ELx弹入到PSTATE，切换到 <code>SPSR_ELx</code> 指定的异常级别开始取指运行。也就是进入到guest的el1的内核态开始执行。</p>
<pre><code class="language-c">/* Switch to the guest for VHE systems running in EL2 */
static int __kvm_vcpu_run_vhe(struct kvm_vcpu *vcpu)
{
	struct kvm_cpu_context *host_ctxt;
	struct kvm_cpu_context *guest_ctxt;
	u64 exit_code;

	host_ctxt = host_data_ptr(host_ctxt);
	guest_ctxt = &amp;vcpu-&gt;arch.ctxt;

	fpsimd_lazy_switch_to_guest(vcpu);

	sysreg_save_host_state_vhe(host_ctxt);

	/*
	 * Note that ARM erratum 1165522 requires us to configure both stage 1
	 * and stage 2 translation for the guest context before we clear
	 * HCR_EL2.TGE. The stage 1 and stage 2 guest context has already been
	 * loaded on the CPU in kvm_vcpu_load_vhe().
	 */
	__activate_traps(vcpu);//设置捕获敏感指令，x86是通过vmcs里的字段控制，由特定指令载入寄存器。

	__kvm_adjust_pc(vcpu);
	//Guest 关键寄存器（如 ELR_EL2）设置放在 C 层,__guest_enter汇编只负责上下文切换。
	sysreg_restore_guest_state_vhe(guest_ctxt);//设置guest的PC寄存器值elr寄存器，方便eret

	do {
		/* Jump in the fire! */
		exit_code = __guest_enter(vcpu);//这里bl__guest_enter，lr寄存器记录返回地址。最终__guest_exit执行ret，返回exit_code

		/* And we're baaack! */
	} while (fixup_guest_exit(vcpu, &amp;exit_code));//如果可以在el2快速处理就直接处理，不能则回到用户空间。

	sysreg_save_guest_state_vhe(guest_ctxt);

	__deactivate_traps(vcpu);

	sysreg_restore_host_state_vhe(host_ctxt);

	/*
	 * Ensure that all system register writes above have taken effect
	 * before returning to the host. In VHE mode, CPTR traps for
	 * FPSIMD/SVE/SME also apply to EL2, so FPSIMD/SVE/SME state must be
	 * manipulated after the ISB.
	 */
	isb();
	...
	return exit_code;
}
NOKPROBE_SYMBOL(__kvm_vcpu_run_vhe);

//sysreg-sr.c  
void sysreg_restore_guest_state_vhe(struct kvm_cpu_context *ctxt) {
    __sysreg_restore_common_state(ctxt);
    __sysreg_restore_el2_return_state(ctxt);
}    
//sysreg-sr.h：
static inline void __sysreg_restore_el2_return_state(struct kvm_cpu_context *ctxt) {
    // ...
    write_sysreg_el2(ctxt-&gt;regs.pc, SYS_ELR);//将PC值写入elr寄存器，方便eret
    write_sysreg_el2(pstate, SYS_SPSR);
}
</code></pre>
<h4 id="__guest_enter汇编入口"><a class="header" href="#__guest_enter汇编入口">__guest_enter汇编入口</a></h4>
<p>__guest_enter的实现：</p>
<ul>
<li>
<p>保存hyp上下文到kvm_hyp_ctxt，包括处于el2运行级别的通用寄存器和el0级的host用户栈sp_el0。</p>
</li>
<li>
<p>恢复guest上下文，处于el1运行级别的通用寄存器和el0级的guest用户栈sp_el0。</p>
</li>
<li>
<p>eret跳转到guest的PC寄存器，开始执行。</p>
<pre><code class="language-c">// Restore guest regs x0-x17,
// Restore guest regs x18-x29和lr
恢复上下文这里，为啥分成两段写，我觉得有点奇怪。
</code></pre>
</li>
</ul>
<p>guest代码执行到敏感指令，触发异常，从guest的el1陷入到host的el2，进入el2_sync向量，这是一段垫片代码，最终执行到__guest_exit，将perCPU变量上保存的vcpu地址作为参数。</p>
<p>虽然guest陷入到el2，也是中断向量处理，但是hypervisor的中断向量不像内核的系统调用和中断那样先将用户态的上下文压栈保存到内核，返回用户态的时候恢复。不管是guest el1还是el0陷入el2，el2也只是使用sp_el2，sp_el1还静静的在哪，当返回到guest用户空间的时候，sp_el0会被覆盖。因此在切换回guest的时候，只需要恢复sp_el0，guest el1和el0的栈寄存器都和切换之前一样。</p>
<pre><code class="language-asm">// arch/arm64/kvm/hyp/hyp-entry.S

el2_sync:
	/* Check for illegal exception return */
	mrs	x0, spsr_el2//读取到x0，spsr_el2记录了异常发生前的 PSTATE（如异常级、条件码、中断屏蔽等）
	tbnz	x0, #20, 1f //如果 SPSR_EL2 的 SS 位为 1，说明这是一个非法的 ERET 异常，就跳转到标签 1 处进行特殊处理。

	save_caller_saved_regs_vect //保存所有调用者保存的寄存器到堆栈上
	stp     x29, x30, [sp, #-16]! //将帧指针 x29 和链接寄存器 x30 压栈。这是在为调用 C 函数准备标准的堆栈帧。
	bl	kvm_unexpected_el2_exception //进入异常处理
	ldp     x29, x30, [sp], #16
	restore_caller_saved_regs_vect

	eret

1:
	/* Let's attempt a recovery from the illegal exception return */
	get_vcpu_ptr	x1, x0 //获取percpu上保存的vcpu传入给__guest_exit
	mov	x0, #ARM_EXCEPTION_IL
	b	__guest_exit

el1_sync:  // 同步异常（如 Data Abort）
    ...
	b.ne	el1_trap
el1_trap:
	get_vcpu_ptr	x1, x0
	mov	x0, #ARM_EXCEPTION_TRAP
	b	__guest_exit

//u64 __guest_enter(struct kvm_vcpu *vcpu);
SYM_FUNC_START(__guest_enter)
	// x0: vcpu，又是返回值
	// x1-x17: clobbered by macros
	// x29: guest context
    // x2 辅助计算。
	adr_this_cpu x1, kvm_hyp_ctxt, x2 //从cpu上获取 kvm_cpu_context对象的地址

	// Store the hyp regs
	save_callee_saved_regs x1//将当前调用者(已经进入到el2了，当前调用这个函数的就是hyp)x18-x30的寄存器保存到上下文。

	// Save hyp's sp_el0
	save_sp_el0	x1, x2 //将用户空间栈sp_el0保存到kvm_hyp_ctxt上下文。在进入__guest_enter前，都是执行Hypervisor的C代码，先系统调用，。
    //将hyp的上下文记录完。

	// Now the hyp state is stored if we have a pending RAS SError it must
	// affect the host or hyp. If any asynchronous exception is pending we
	// defer the guest entry. The DSB isn't necessary before v8.2 as any
	// SError would be fatal.
alternative_if ARM64_HAS_RAS_EXTN
	dsb	nshst
	isb
alternative_else_nop_endif
	mrs	x1, isr_el1
	cbz	x1,  1f
	mov	x0, #ARM_EXCEPTION_IRQ
	ret
1:
	set_loaded_vcpu x0, x1, x2

	add	x29, x0, #VCPU_CONTEXT，取x0的偏移赋值给x29,x29=vcpu-&gt;kvm_cpu_context

	// mte_switch_to_guest(g_ctxt, h_ctxt, tmp1)
	mte_switch_to_guest x29, x1, x2

	// Macro ptrauth_switch_to_guest format:
	// 	ptrauth_switch_to_guest(guest cxt, tmp1, tmp2, tmp3)
	// The below macro to restore guest keys is not implemented in C code
	// as it may cause Pointer Authentication key signing mismatch errors
	// when this feature is enabled for kernel code.
	ptrauth_switch_to_guest x29, x0, x1, x2

	// Restore the guest's sp_el0
	restore_sp_el0 x29, x0//将vcpu的sp_el0恢复到sp_el0，用户栈

	// Restore guest regs x0-x17,从x29的偏移取一对数据。
	ldp	x0, x1,   [x29, #CPU_XREG_OFFSET(0)]
	ldp	x2, x3,   [x29, #CPU_XREG_OFFSET(2)]
	ldp	x4, x5,   [x29, #CPU_XREG_OFFSET(4)]
	ldp	x6, x7,   [x29, #CPU_XREG_OFFSET(6)]
	ldp	x8, x9,   [x29, #CPU_XREG_OFFSET(8)]
	ldp	x10, x11, [x29, #CPU_XREG_OFFSET(10)]
	ldp	x12, x13, [x29, #CPU_XREG_OFFSET(12)]
	ldp	x14, x15, [x29, #CPU_XREG_OFFSET(14)]
	ldp	x16, x17, [x29, #CPU_XREG_OFFSET(16)]

	// Restore guest regs x18-x29和lr
	restore_callee_saved_regs x29 //从vcpu恢复lr
	//为什么elr_el2不在这里恢复？要在sysreg_restore_guest_state_vhe
	
	// Do not touch any register after this!
	eret	//这里跳转到elr_el2，也就是VCPU的PC,进入guest代码执行
/*
用户空间（EL0）通过 ioctl 进入 KVM 内核代码（EL1）。
内核代码（EL1）最终调用 __kvm_vcpu_run，准备好上下文后，通过 SMC/HVC 或跳转机制切换到 EL2。
在 EL2 下，执行 __guest_enter，完成虚拟机上下文切换，eret 进入 Guest（EL1/EL0）。
*/
	sb 
	
/*sb 指令是 ARMv8 架构中的 “Speculation Barrier”（推测屏障）指令。
作用：
用于防止 CPU 执行推测性指令带来的安全隐患（如 Spectre 类漏洞）。
它会阻止指令流中在 sb 之前的所有内存访问被推测性地重排序到 sb 之后。
确保异常返回前后的执行环境不会被推测执行影响，提升安全性。
*/
</code></pre>
<h4 id="__guest_exit"><a class="header" href="#__guest_exit">__guest_exit</a></h4>
<p>__guest_exit的实现：</p>
<ul>
<li>从vcpu获取kvm_cpu_context对象（vcpu-&gt;kvm_cpu_context）。将guest上下文保存到kvm_cpu_context对象，guest的通用寄存器和sp_el0。</li>
<li>将从percpu获取kvm_hyp_ctxt对象，恢复host上下文，sp_el0和通用寄存器（当然包括lr/x30寄存器）。</li>
<li>ret 跳转到__guest_enter的下一条指令，<code> exit_code=__guest_enter</code> 后的指令，此时以及回到hyp的C上下文。</li>
</ul>
<pre><code class="language-asm">
// arch/arm64/kvm/hyp/entry.S
SYM_INNER_LABEL(__guest_exit, SYM_L_GLOBAL)
	// x0: return code
	// x1: vcpu
	// x2-x29,lr: vcpu regs
	// vcpu x0-x1 on the stack
0
	add	x1, x1, #VCPU_CONTEXT//x1指向vcpu的vcpu_context

	ALTERNATIVE(nop, SET_PSTATE_PAN(1), ARM64_HAS_PAN, CONFIG_ARM64_PAN)

	// Store the guest regs x2 and x3
	stp	x2, x3,   [x1, #CPU_XREG_OFFSET(2)]

	// Retrieve the guest regs x0-x1 from the stack
	ldp	x2, x3, [sp], #16	// x0, x1

	// Store the guest regs x0-x1 and x4-x17
	stp	x2, x3,   [x1, #CPU_XREG_OFFSET(0)]
	stp	x4, x5,   [x1, #CPU_XREG_OFFSET(4)]
	stp	x6, x7,   [x1, #CPU_XREG_OFFSET(6)]
	stp	x8, x9,   [x1, #CPU_XREG_OFFSET(8)]
	stp	x10, x11, [x1, #CPU_XREG_OFFSET(10)]
	stp	x12, x13, [x1, #CPU_XREG_OFFSET(12)]
	stp	x14, x15, [x1, #CPU_XREG_OFFSET(14)]
	stp	x16, x17, [x1, #CPU_XREG_OFFSET(16)]
//依次将 x0-x17 的值保存到 vcpu 的上下文结构体（VCPU_CONTEXT）对应偏移。
//这样做保证异常发生时，Guest 的所有通用寄存器都能被 Hypervisor 完整保存。
	// Store the guest regs x18-x29, lr
	save_callee_saved_regs x1

	// Store the guest's sp_el0
	save_sp_el0	x1, x2
//先保存vcpu上下文，在加载percpu绑定的变量上面的host cpu上下文，这个上下文是切换到guest前保存的。
	adr_this_cpu x2, kvm_hyp_ctxt, x3 //load cpu上找到切换前的上下文到x2，切换前是cpu上下文是Hypervisor的代码。

	// Macro ptrauth_switch_to_hyp format:
	// 	ptrauth_switch_to_hyp(guest cxt, host cxt, tmp1, tmp2, tmp3)
	// The below macro to save/restore keys is not implemented in C code
	// as it may cause Pointer Authentication key signing mismatch errors
	// when this feature is enabled for kernel code.
	ptrauth_switch_to_hyp x1, x2, x3, x4, x5

	// mte_switch_to_hyp(g_ctxt, h_ctxt, reg1)
	mte_switch_to_hyp x1, x2, x3

	// Restore hyp's sp_el0
	restore_sp_el0 x2, x3 //从x2里恢复sp_el0，hyp的C代码执行环境。
/*
host 可以el2内核和hyp，el0用户态
guest 可以el1内核，el0用户态
不管是guest还是host，只有一个用户异常级别sp_el0可用，因此要保存以及恢复。

vcpu-&gt;arch.ctxt.sp 保存 Guest 的 SP_EL0
kvm_hyp_ctxt.sp（per-CPU）保存 hyp/Host 的 SP_EL0，也就是qemu的栈。
*/
	// Now restore the hyp regs
	restore_callee_saved_regs x2 //从x2对象里恢复寄存器，包括lr。

	set_loaded_vcpu xzr, x2, x3

alternative_if ARM64_HAS_RAS_EXTN
	// If we have the RAS extensions we can consume a pending error
	// without an unmask-SError and isb. The ESB-instruction consumed any
	// pending guest error when we took the exception from the guest.
	mrs_s	x2, SYS_DISR_EL1
	str	x2, [x1, #(VCPU_FAULT_DISR - VCPU_CONTEXT)]
	cbz	x2, 1f
	msr_s	SYS_DISR_EL1, xzr
	orr	x0, x0, #(1&lt;&lt;ARM_EXIT_WITH_SERROR_BIT)
1:	ret
/*__guest_exit直接的返回值就是__guest_enter一次guest的返回值*/

</code></pre>
<p>整体上，可以把__guest_enter看做一个执行上下文切换并运行guest代码的函数。</p>
<p>我们在回到_kvm_arch_vcpu_ioctl_run来看，不管是_<code>__kvm_vcpu_run</code>还是<code>__kvm_vcpu_run_vhe</code>，都有eret进入guest，从<code>__guest_exit</code>返回只有ret返回，也就是任然工作在el2。</p>
<p>nvhe严格的划分：host部分代码运行在el1，hyp部分运行el2。那么什么时候实现 hyp el2会到host el1的呢？答案就在<code>kvm_call_hyp_ret</code>宏，它的返回就代表从el2回到了el1，会单独开辟nvhe流程章节分析讲解。</p>
<hr>
<h3 id="3-stage-2-地址翻译"><a class="header" href="#3-stage-2-地址翻译">3. Stage-2 地址翻译</a></h3>
<p>host和guest上下文切换属于CPU虚拟化的知识范畴，stage-2地址翻译属于内存虚拟化的范畴，但是这两者紧密相关。所以在这里会简单的做一些介绍。</p>
<p>当CPU切换到guest后，从PC寄存器保存的地址取指运行，就涉及到度内存的访问。</p>
<p>在host用户空间分配的虚拟地址，作为虚拟机的物理地址，CPU是如何读取上面的数据并执行的呢？</p>
<pre><code class="language-c">// QEMU
ioctl(fd, KVM_CREATE_VM, type)；//最终会调用kvm_init_stage2_mmu创建页表。
void *ram = mmap(NULL, 0x1000000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
// ram = 0x7f1234560000 (Host userspace VA)，host用户空间分配的地址。

// 告诉 KVM：Guest 的 0x0 ~ 0x1000000 是 RAM
kvm_userspace_memory_region reg = {
    .guest_phys_addr = 0x0,
    .memory_size     = 0x1000000,
    .userspace_addr  = (uint64_t)ram,
};
ioctl(vm_fd, KVM_SET_USER_MEMORY_REGION, &amp;reg);
// 此时 Host 物理页尚未分配（可能还在 swap 或 zero page）
</code></pre>
<p>kvm对象创建的时候，就会给S2页表对象创建，<strong>保证VTTBR_EL2不为空。</strong></p>
<p>此时，我们将ELR_EL2 = 0x0，SCTLR_EL1.M = 0（关闭MMU，不启用S1翻译，所以不用判段地址是高还是低，不适用TTBR0_EL1/TTBR1_EL1），执行eret的时候，PC寄存器开始从0x0的物理虚拟物理地址开始读取。</p>
<pre><code class="language-c">PC = 0x0 (VA)
  ↓
Stage-1 （SCTLR_EL1.M=0，，通常 MMU 关闭，假设 Guest 尚未设置页表，如刚启动），
  → 不翻译。（不使用 Guest TTBR0_EL1/TTBR1_EL1 ）
  → 此时 VA = IPA = 0x0
  ↓
Stage-2 （HCR_EL2.VM = 1，开启翻译）
  → 部件TLB未命中 → 页表walk发现PTE无效 → 触发Stage-2 Translation Fault → Trap到kvm EL2处理缺页。→ __guest_exit退出
    ...-&gt;直到kvm_arch_vcpu_ioctl_run-&gt;
        -&gt;handle_exit-&gt;handle_trap_exceptions（处理ESR_ELx_EC_IABT_LOW异常）
        	-&gt;...-&gt;user_mem_abort（处理内存错误）-&gt;kvm_pgtable_stage2_map（实现填充页表项，刷新页表缓存）//在el2内处理完后handle_exit返回。
        -&gt;kvm_arm_vcpu_enter_exit -&gt; ...-&gt;__guest_enter //根据handle_exit返回值，决定继续进入guest执行。
  → IPA 0x0 已被你映射到 Host 的 ram 物理页（使用VTTBR_EL2页表寄存器）
  → 再次访问IPA=0x0，得到真实 PA
  ↓
从该物理页读取指令 → 成功！
</code></pre>
<p>如果开启Stage-1翻译，相当于KVM_SET_USER_MEMORY_REGION提供了物理地址(IPA)给guest EL1内核，guest内核负责管理物理内存，以及创建Stage-1的页表，就是内核正常的初始化物理内存的过程。guest的虚拟地址，都是要通过其 EL1内核分配。</p>
<h2 id="关键数据结构和寄存器"><a class="header" href="#关键数据结构和寄存器">关键数据结构和寄存器</a></h2>
<pre><code class="language-text">kvm (虚拟机实例)
├── 内存管理
│   ├── kvm_memslots[] (内存插槽)
│   └── mmu_lock (MMU锁)
├── vCPU数组
│   └── kvm_vcpu[] (虚拟CPU)
│       ├── 用户空间接口
│       │   └── kvm_run (通信接口)
│       └── 架构特定状态
│           └── kvm_vcpu_arch
│               ├── CPU上下文
│               │   └── kvm_cpu_context
│               │       ├── regs (通用寄存器)
│               │       ├── fp_regs (FP/SIMD寄存器)
│               │       └── sys_regs (系统寄存器)
│               ├── 地址转换
│               │   └── kvm_s2_mmu *hw_mmu
│               │       ├── vmid (虚拟机ID)
│               │       ├── pgd_phys (页表物理地址)
│               │       └── pgt (页表结构)
│               ├── 虚拟外设
│               │   ├── vgic_cpu (虚拟中断控制器)
│               │   ├── timer (虚拟定时器)
│               │   └── pmu (性能监控单元)
│               └── 嵌套虚拟化
│                   └── *nested_mmus
└── 架构特定数据
    └── kvm_arch

Per-CPU Host状态
└── kvm_host_data[]
    └── host_ctxt (Host CPU上下文)
        ├── regs (Host寄存器)
        ├── fp_regs (Host FP状态)
        └── sys_regs (Host系统寄存器)
</code></pre>
<h3 id="1-kvm---虚拟机实例"><a class="header" href="#1-kvm---虚拟机实例">1. kvm - 虚拟机实例</a></h3>
<p><strong>文件位置</strong>: <code>include/linux/kvm_host.h</code></p>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm {
#ifdef KVM_HAVE_MMU_RWLOCK
    rwlock_t mmu_lock;
#else
    spinlock_t mmu_lock;
#endif
    struct mutex slots_lock;
    struct mutex slots_arch_lock;
    struct mm_struct *mm;               // 用户空间内存描述符
    unsigned long nr_memslot_pages;
    struct kvm_memslots __memslots[KVM_MAX_NR_ADDRESS_SPACES][2]; // 内存插槽
    struct kvm_vcpu *vcpus[KVM_MAX_VCPUS]; // vCPU数组
    struct kvm_arch arch;               // 架构特定数据
    atomic_t online_vcpus;             // 在线vCPU计数
    long vcpus_in_guest;                // 在guest中的vCPU数
};
</code></pre>
<p><strong>主要作用</strong>：</p>
<ul>
<li>代表一个完整的虚拟机实例</li>
<li>管理虚拟机的内存、设备和vCPU</li>
<li>提供虚拟机级别的配置和控制</li>
</ul>
<h3 id="2-kvm_vcpu---虚拟cpu核心结构体"><a class="header" href="#2-kvm_vcpu---虚拟cpu核心结构体">2. kvm_vcpu - 虚拟CPU核心结构体</a></h3>
<pre><code class="language-c">struct kvm_vcpu {
    struct kvm *kvm;                    // 所属虚拟机实例
    int cpu, vcpu_id, vcpu_idx;         // 物理CPU映射和虚拟ID
    struct kvm_run *run;                // 用户空间通信结构
    struct kvm_vcpu_arch arch;          // 架构特定状态
    struct kvm_vcpu_stat stat;          // 统计信息
    int mode;                           // 执行模式(IN_GUEST_MODE等)
    bool wants_to_run;                  // 运行意愿标记
    int preempted;                      // 抢占状态
    void *guest_debug;                  // 调试支持
};
</code></pre>
<p><strong>主要作用</strong>：</p>
<ul>
<li>代表一个虚拟CPU实例，是虚拟化的基本单位</li>
<li>管理vCPU的生命周期和调度</li>
<li>协调guest和host之间的状态切换</li>
<li>提供统计信息跟踪和性能监控</li>
</ul>
<h3 id="3-kvm_run---用户空间通信接口"><a class="header" href="#3-kvm_run---用户空间通信接口">3. kvm_run - 用户空间通信接口</a></h3>
<p><strong>文件位置</strong>: <code>include/uapi/linux/kvm.h</code></p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>作为用户空间和内核空间KVM的通信桥梁</li>
<li>传递guest退出原因和处理请求</li>
<li>提供同步接口和数据交换</li>
</ul>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm_run {
    __u8 request_interrupt_window;      // 请求中断窗口
    __u8 immediate_exit;                // 立即退出标记
    __u8 padding1[6];
    __u32 exit_reason;                  // 退出原因
    __u8 ready_for_interrupt_injection; // 中断注入准备状态
    __u8 if_flag;                       // 中断标志
    __u16 flags;                        // 状态标志
    __u64 cr8;                          // x86 CR8寄存器
    __u64 apic_base;                    // APIC基地址
    // 架构特定的退出信息联合体
};
</code></pre>
<h3 id="4-kvm_vcpu_arch---arm架构特定的vcpu状态"><a class="header" href="#4-kvm_vcpu_arch---arm架构特定的vcpu状态">4. kvm_vcpu_arch - ARM架构特定的vCPU状态</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_host.h</code></p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>存储ARM架构特定的vCPU完整状态</li>
<li>包含guest的处理器上下文和虚拟化配置</li>
<li>管理ARM特定的虚拟化特性</li>
</ul>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm_vcpu_arch {
    struct kvm_cpu_context ctxt;        // CPU上下文(核心)
    void *sve_state;                    // SVE(可伸缩向量扩展)状态
    enum fp_type fp_type;               // 浮点类型
    struct kvm_s2_mmu *hw_mmu;          // 二级地址转换MMU
    u64 hcr_el2, hcrx_el2, mdcr_el2;    // 虚拟化控制寄存器
    struct kvm_vcpu_fault_info fault;  // 缺页错误信息
    struct vgic_cpu vgic_cpu;           // 虚拟GIC状态
    struct kvm_timer timer;             // 虚拟定时器
    struct kvm_pmu pmu;                 // 性能监控单元
    u64 trfcr_while_in_guest;          // 跟踪过滤器配置
    struct kvm_s2_mmu mmu;              // 二级MMU
    struct kvm_s2_mmu *nested_mmus;     // 嵌套虚拟化MMU
};
</code></pre>
<p><strong>关键特性</strong>：</p>
<ul>
<li><code>ctxt</code>字段是上下文切换的核心</li>
<li><code>hw_mmu</code>指向实际使用的地址转换结构</li>
<li>支持嵌套虚拟化(nested_mmus)</li>
<li>包含完整的虚拟外设状态(GIC、定时器、PMU)</li>
</ul>
<h3 id="5-kvm_cpu_context---cpu上下文状态"><a class="header" href="#5-kvm_cpu_context---cpu上下文状态">5. kvm_cpu_context - CPU上下文状态</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_host.h</code></p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>存储完整的CPU寄存器状态</li>
<li>在上下文切换时保存和恢复处理器状态</li>
<li>作为guest和host状态切换的载体</li>
</ul>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm_cpu_context {
    struct user_pt_regs regs;           // 通用寄存器(x0-x30, sp, pc)
    u64 spsr_abt, spsr_und, spsr_irq, spsr_fiq;  // 异常状态寄存器
    struct user_fpsimd_state fp_regs;   // FP/SIMD寄存器
    u64 sys_regs[NR_SYS_REGS];          // 系统寄存器
    struct kvm_vcpu *__hyp_running_vcpu; // hypervisor运行中的vCPU
    u64 *vncr_array;                    // 嵌套虚拟化寄存器
};
</code></pre>
<p><strong>寄存器组分类</strong>：</p>
<ol>
<li><strong>通用寄存器</strong> (regs): x0-x30, sp, pc</li>
<li><strong>异常状态寄存器</strong>: SPSR_ABT, SPSR_UND, SPSR_IRQ, SPSR_FIQ</li>
<li><strong>浮点/SIMD寄存器</strong> (fp_regs): V0-V31, FPSR, FPCR</li>
<li><strong>系统寄存器</strong> (sys_regs): SCTLR, TCR, TTBR等</li>
</ol>
<h3 id="6-kvm_host_data---host状态管理"><a class="header" href="#6-kvm_host_data---host状态管理">6. kvm_host_data - Host状态管理</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_host.h</code></p>
<p><strong>主要作用</strong>：</p>
<ul>
<li>管理hypervisor的host状态</li>
<li>提供Per-CPU数据存储</li>
<li>管理host的系统寄存器上下文</li>
</ul>
<p><strong>关键字段</strong>：</p>
<pre><code class="language-c">struct kvm_host_data {
#define KVM_HOST_DATA_FLAG_HAS_SPE            0
#define KVM_HOST_DATA_FLAG_HAS_TRBE           1
#define KVM_HOST_DATA_FLAG_TRBE_ENABLED       4
#define KVM_HOST_DATA_FLAG_EL1_TRACING_CONFIGURED  5
#define KVM_HOST_DATA_FLAG_VCPU_IN_HYP_CONTEXT   6
#define KVM_HOST_DATA_FLAG_L1_VNCR_MAPPED       7
#define KVM_HOST_DATA_FLAG_HAS_BRBE           8
    unsigned long flags;                 // 状态标志位
    struct kvm_cpu_context host_ctxt;   // host的CPU上下文
};
</code></pre>
<p><strong>重要特性</strong>：</p>
<ul>
<li>Per-CPU数据结构，每个物理CPU一个实例</li>
<li>通过标志位管理各种硬件特性</li>
<li><code>host_ctxt</code>保存host的完整状态</li>
</ul>
<h3 id="7-kvm_s2_mmu-stage2映射"><a class="header" href="#7-kvm_s2_mmu-stage2映射">7. kvm_s2_mmu Stage2映射</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_host.h</code></p>
<pre><code class="language-c">struct kvm_s2_mmu {
	struct kvm_vmid vmid;
	phys_addr_t	pgd_phys;       // PGD 物理地址
	struct kvm_pgtable *pgt;    // Stage2 页表
	int __percpu *last_vcpu_ran;// 每个 CPU 最后运行的 VCPU
	struct kvm_arch *arch;      // 架构特定数据
};
</code></pre>
<p><strong>主要作用</strong>：</p>
<ul>
<li>管理guest的二级地址转换（Stage 2 Translation）</li>
<li>实现内存虚拟化，隔离guest物理内存</li>
<li>管理虚拟地址到物理地址的映射</li>
</ul>
<h3 id="8-kvm_pgtable-stage2页表"><a class="header" href="#8-kvm_pgtable-stage2页表">8. kvm_pgtable Stage2页表</a></h3>
<p><strong>文件位置</strong>: <code>arch/arm64/include/asm/kvm_pgtable.h</code></p>
<pre><code class="language-c">struct kvm_pgtable {
    u32                            ia_bits;        // IPA 地址位数
    u32                            start_level;    // 起始页表级别
    kvm_pte_t                      *pgd;           // PGD 页表根指针
    struct kvm_pgtable_mm_ops     *mm_ops;        // 内存操作回调
    struct kvm_s2_mmu              *mmu;           // 关联的 MMU
    enum kvm_pgtable_stage2_flags  flags;          // 标志位
    kvm_pgtable_force_pte_cb_t    force_pte_cb;   // 强制 PTE 回调
};
</code></pre>
<hr>
<p><em>参考文件：arch/arm64/kvm/arm.c, arch/arm64/kvm/hyp/</em>/switch.c, arch/arm64/kvm/hyp/entry.S</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nvhe的调用过程"><a class="header" href="#nvhe的调用过程">nVHE的调用过程</a></h1>
<h2 id="nvhe调用路径"><a class="header" href="#nvhe调用路径">nVHE调用路径</a></h2>
<p>nvhe的完整路径，host el1 -&gt; hyp el2 -&gt;host el1的过程。</p>
<pre><code>[主机调用]: kvm_call_hyp_ret(__kvm_vcpu_run, vcpu) 
     ↓
[展开为]: arm_smccc_1_1_hvc(KVM_HOST_SMCCC_FUNC(__kvm_vcpu_run), vcpu, &amp;res)
     ↓
[执行]: hvc #0 (x0=KVM功能号, x1=vcpu)
     ↓
[异常处理]: host_el1_sync_vect → __host_hvc → __host_exit
     ↓
[调用处理]: handle_trap → handle_host_hcall → host_hcall[KVM_FUNC_IDX] → handle___kvm_vcpu_run → __kvm_vcpu_run(vcpu)
     ↓
[返回]: __host_exit(vcpu) -&gt;eret
     ↓
[返回]: kvm_call_hyp_ret
</code></pre>
<p>__kvm_vcpu_run内恢复host el1的 pc 寄存器，<code>__host_exit</code>最后ret，后续会讲到。</p>
<p>kvm_call_hyp_ret展开</p>
<pre><code class="language-c">{
     struct arm_smccc_res res;
     
     // KVM_HOST_SMCCC_FUNC(__kvm_vcpu_run) 展开为 (ARM_SMCCC_OWNER_KVM &lt;&lt; ARM_SMCCC_OWNER_SHIFT) |      __KVM_HOST_SMCCC_FUNC___kvm_vcpu_run
     // 假设 __KVM_HOST_SMCCC_FUNC___kvm_vcpu_run = 19
     typeof(vcpu) __a1 = vcpu;                           // arg1 = vcpu
     struct arm_smccc_res *___res = &amp;res;                // ___res = &amp;res
     register unsigned long arg0 asm("r0") = (u32)((ARM_SMCCC_OWNER_KVM &lt;&lt; ARM_SMCCC_OWNER_SHIFT) | 19); // arg0=function ID
     register typeof(vcpu) arg1 asm("r1") = __a1;        // arg1=vcpu
     
     // 汇编部分
     register unsigned long r0 asm("r0");      // 用于接收返回值
     register unsigned long r1 asm("r1");      // 用于接收返回值
     register unsigned long r2 asm("r2");      // 用于接收返回值
     register unsigned long r3 asm("r3");      // 用于接收返回值
     
     asm volatile("hvc     #0\n :                // SMCCC_HVC_INST = "hvc  #0"
                  "=r" (r0), "=r" (r1), "=r" (r2), "=r" (r3)
                  : "r" (arg0), "r" (arg1)    // function ID and vcpu
                  : "memory");
     
     if (___res) {
         *___res = (typeof(*___res)){r0, r1, r2, r3};   // 将返回值存入res结构体
     }
     
     WARN_ON(res.a0 != SMCCC_RET_SUCCESS);    // 检查返回状态
     
     ret = res.a1;  // 返回函数执行结果
 }
</code></pre>
<h2 id="hyp异常向量表映射"><a class="header" href="#hyp异常向量表映射">hyp异常向量表映射</a></h2>
<p>__kvm_hyp_host_vector的结构是这样的（每个异常类型对应一个64字节的槽）：</p>
<pre><code>__kvm_hyp_host_vector:  // 基地址 (VBAR_EL2)
├─ [0x000] Synchronous EL2t     → invalid_host_el2_vect
├─ [0x080] IRQ EL2t             → invalid_host_el2_vect  
├─ [0x100] FIQ EL2t             → invalid_host_el2_vect
├─ [0x180] Error EL2t           → invalid_host_el2_vect
├─ [0x200] Synchronous EL2h     → invalid_host_el2_vect
├─ [0x280] IRQ EL2h             → invalid_host_el2_vect
├─ [0x300] FIQ EL2h             → invalid_host_el2_vect
├─ [0x380] Error EL2h           → invalid_host_el2_vect
├─ [0x400] Synchronous 64-bit EL1/EL0 → host_el1_sync_vect
├─ [0x480] IRQ 64-bit EL1/EL0   → invalid_host_el1_vect
├─ [0x500] FIQ 64-bit EL1/EL0   → invalid_host_el1_vect
├─ [0x580] Error 64-bit EL1/EL0 → invalid_host_el1_vect
├─ [0x600] Synchronous 32-bit EL1/EL0 → host_el1_sync_vect
├─ [0x680] IRQ 32-bit EL1/EL0   → invalid_host_el1_vect
├─ [0x700] FIQ 32-bit EL1/EL0   → invalid_host_el1_vect
├─ [0x780] Error 32-bit EL1/EL0 → invalid_host_el1_vect
</code></pre>
<p>中断向量执行流程</p>
<pre><code class="language-asm">EL1执行: hvc #0 (功能号在x0中)
↓
ARM处理器检测到HVC #0异常
↓
根据ESR_EL2确定异常来源为EL1/EL0
↓
查找向量表: VBAR_EL2 + 0x400 (Synchronous 64-bit EL1/EL0的偏移)
↓
跳转到: host_el1_sync_vect (定义在host.S中)
↓
host_el1_sync_vect宏执行:
         stp x0, x1, [sp, #-16]!    // 保存x0, x1到栈
         mrs x0, esr_el2            // 读取ESR
         ubfx x0, x0, #ESR_ELx_EC_SHIFT, #ESR_ELx_EC_WIDTH  // 提取异常类
         cmp x0, #ESR_ELx_EC_HVC64  // 检查是否为HVC64异常类
         b.eq __host_hvc            // 如果是HVC64，跳转到__host_hvc
         b __host_exit              // 否则，跳转到__host_exit
↓
执行: __host_hvc (在host.S中)
</code></pre>
<p>host_el1_sync_vect中断向量的核心是判断是否为HVC64异常。x0是功能号，x1是参数，如vpcu指针。</p>
<p>压栈是为了传递给__host_hvc。</p>
<h2 id="异常处理分发"><a class="header" href="#异常处理分发">异常处理分发</a></h2>
<p><code>__host_hvc</code>根据x0记录的kvm功能号是判断是hvc还是其他调用，x0=<code>__KVM_HOST_SMCCC_FUNC___kvm_vcpu_run</code>。</p>
<pre><code class="language-asm">SYM_FUNC_START(__host_hvc)
	ldp	x0, x1, [sp]		// Don't fixup the stack yet

	/* No stub for you, sonny Jim */
alternative_if ARM64_KVM_PROTECTED_MODE//KVM_保护模式直接退出
	b	__host_exit
alternative_else_nop_endif

	/* Check for a stub HVC call */
	cmp	x0, #HVC_STUB_HCALL_NR //成立
	b.hs	__host_exit //普通kvm hvc调用。

	add	sp, sp, #16
	/*
	 * Compute the idmap address of __kvm_handle_stub_hvc and
	 * jump there.
	 *
	 * Preserve x0-x4, which may contain stub parameters.
	 */
	adr_l	x5, __kvm_handle_stub_hvc
	hyp_pa	x5, x6
	br	x5
SYM_FUNC_END(__host_hvc)
</code></pre>
<p>__host_exit的核心功能就是保存host上下文，从perCPU变量获取指针到x0寄存器，将当前的各种寄存器存这个上下文。在进入异常和中断向量之前，这些寄存器属于el1 host在用，而中断向量中间也只是少量的使用寄存器，且做到了用后恢复。</p>
<p>到然后进入handle_trap，执行具体的hvc功能函数调用，需要host的上下文作为参数提供功能号。</p>
<p>handle_trap</p>
<h2 id="保存host上下文进入到hyp上下文"><a class="header" href="#保存host上下文进入到hyp上下文">保存host上下文，进入到hyp上下文</a></h2>
<p><code>__host_exit</code>先保存host上下文，handle_trap执行hyp功能号对应的函数，返回后，继续执行到eret返回host el1。</p>
<pre><code class="language-asm">SYM_FUNC_START(__host_exit)
	get_host_ctxt	x0, x1

	/* Store the host regs x2 and x3 */
	stp	x2, x3,   [x0, #CPU_XREG_OFFSET(2)]

	/* Retrieve the host regs x0-x1 from the stack */
	ldp	x2, x3, [sp], #16	// x0, x1

	/* Store the host regs x0-x1 and x4-x17 */
	stp	x2, x3,   [x0, #CPU_XREG_OFFSET(0)]
	stp	x4, x5,   [x0, #CPU_XREG_OFFSET(4)]
	stp	x6, x7,   [x0, #CPU_XREG_OFFSET(6)]
	stp	x8, x9,   [x0, #CPU_XREG_OFFSET(8)]
	stp	x10, x11, [x0, #CPU_XREG_OFFSET(10)]
	stp	x12, x13, [x0, #CPU_XREG_OFFSET(12)]
	stp	x14, x15, [x0, #CPU_XREG_OFFSET(14)]
	stp	x16, x17, [x0, #CPU_XREG_OFFSET(16)]

	/* Store the host regs x18-x29, lr */
	save_callee_saved_regs x0

	/* Save the host context pointer in x29 across the function call */
	mov	x29, x0

#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL
alternative_if_not ARM64_HAS_ADDRESS_AUTH
b __skip_pauth_save
alternative_else_nop_endif

alternative_if ARM64_KVM_PROTECTED_MODE
	/* Save kernel ptrauth keys. */
	add x18, x29, #CPU_APIAKEYLO_EL1
	ptrauth_save_state x18, x19, x20

	/* Use hyp keys. */
	adr_this_cpu x18, kvm_hyp_ctxt, x19
	add x18, x18, #CPU_APIAKEYLO_EL1
	ptrauth_restore_state x18, x19, x20
	isb
alternative_else_nop_endif
__skip_pauth_save:
#endif /* CONFIG_ARM64_PTR_AUTH_KERNEL */

	bl	handle_trap

__host_enter_restore_full:
	/* Restore kernel keys. */
#ifdef CONFIG_ARM64_PTR_AUTH_KERNEL
alternative_if_not ARM64_HAS_ADDRESS_AUTH
b __skip_pauth_restore
alternative_else_nop_endif

alternative_if ARM64_KVM_PROTECTED_MODE
	add x18, x29, #CPU_APIAKEYLO_EL1
	ptrauth_restore_state x18, x19, x20
alternative_else_nop_endif
__skip_pauth_restore:
#endif /* CONFIG_ARM64_PTR_AUTH_KERNEL */

	/* Restore host regs x0-x17 */
	ldp	x0, x1,   [x29, #CPU_XREG_OFFSET(0)]
	ldp	x2, x3,   [x29, #CPU_XREG_OFFSET(2)]
	ldp	x4, x5,   [x29, #CPU_XREG_OFFSET(4)]
	ldp	x6, x7,   [x29, #CPU_XREG_OFFSET(6)]

	/* x0-7 are use for panic arguments */
__host_enter_for_panic:
	ldp	x8, x9,   [x29, #CPU_XREG_OFFSET(8)]
	ldp	x10, x11, [x29, #CPU_XREG_OFFSET(10)]
	ldp	x12, x13, [x29, #CPU_XREG_OFFSET(12)]
	ldp	x14, x15, [x29, #CPU_XREG_OFFSET(14)]
	ldp	x16, x17, [x29, #CPU_XREG_OFFSET(16)]

	/* Restore host regs x18-x29, lr */
	restore_callee_saved_regs x29

	/* Do not touch any register after this! */
__host_enter_without_restoring:
	eret  //使用eret指令返回到主机
	sb
SYM_FUNC_END(__host_exit)

</code></pre>
<p>在handle_trap里进入到handle_host_hcall分支。</p>
<pre><code class="language-c">arch/arm64/kvm/hyp/nvhe/hyp-main.c
void handle_trap(struct kvm_cpu_context *host_ctxt)
{
	u64 esr = read_sysreg_el2(SYS_ESR);

	switch (ESR_ELx_EC(esr)) {
	case ESR_ELx_EC_HVC64:
		handle_host_hcall(host_ctxt);
		break;
	case ESR_ELx_EC_SMC64:
		handle_host_smc(host_ctxt);
		break;
	case ESR_ELx_EC_IABT_LOW:
	case ESR_ELx_EC_DABT_LOW:
		handle_host_mem_abort(host_ctxt);
		break;
	default:
		BUG();
	}
}

</code></pre>
<p>从host_ctxt取,HVC功能号,然后找到对应的调用函数。</p>
<pre><code class="language-c">
#define cpu_reg(ctxt, r)	(ctxt)-&gt;regs.regs[r]
#define DECLARE_REG(type, name, ctxt, reg)					\
				__always_unused int ___check_reg_ ## reg;	\
				type name = (type)cpu_reg(ctxt, (reg))


static void handle_host_hcall(struct kvm_cpu_context *host_ctxt)
{
   // 从host_ctxt的x0寄存器获取功能号放到id
   // cpu_reg(host_ctxt, 0) 本质上是从host_ctxt-&gt;regs.regs[0]获取值
   // 这个值就是HVC调用时x0寄存器中的功能号

	DECLARE_REG(unsigned long, id, host_ctxt, 0);
	unsigned long hcall_min = 0;
	hcall_t hfn;

	/*
	 * If pKVM has been initialised then reject any calls to the
	 * early "privileged" hypercalls. Note that we cannot reject
	 * calls to __pkvm_prot_finalize for two reasons: (1) The static
	 * key used to determine initialisation must be toggled prior to
	 * finalisation and (2) finalisation is performed on a per-CPU
	 * basis. This is all fine, however, since __pkvm_prot_finalize
	 * returns -EPERM after the first call for a given CPU.
	 */
	if (static_branch_unlikely(&amp;kvm_protected_mode_initialized))
		hcall_min = __KVM_HOST_SMCCC_FUNC___pkvm_prot_finalize;

	id &amp;= ~ARM_SMCCC_CALL_HINTS;
	id -= KVM_HOST_SMCCC_ID(0);

	if (unlikely(id &lt; hcall_min || id &gt;= ARRAY_SIZE(host_hcall)))
		goto inval;

	hfn = host_hcall[id];//先索引到函数
	if (unlikely(!hfn))
		goto inval;

	cpu_reg(host_ctxt, 0) = SMCCC_RET_SUCCESS;
	hfn(host_ctxt);//在跳转到函数

	return;
inval:
	cpu_reg(host_ctxt, 0) = SMCCC_RET_NOT_SUPPORTED;
}
</code></pre>
<p>对应的函数是<code>__kvm_vcpu_run</code>，展开是<code>handle___kvm_vcpu_run</code>,host_hcall数组存储函数指针，索引值<code>__KVM_HOST_SMCCC_FUNC_##x</code>拼接的调用号。</p>
<p>最终在<code>handle___kvm_vcpu_run</code>内调用<code>__kvm_vcpu_run</code>。</p>
<pre><code class="language-c">#define HANDLE_FUNC(x)	[__KVM_HOST_SMCCC_FUNC_##x] = (hcall_t)handle_##x

static const hcall_t host_hcall[] = {
	/* ___kvm_hyp_init */
	HANDLE_FUNC(__pkvm_init),
	HANDLE_FUNC(__pkvm_create_private_mapping),
	HANDLE_FUNC(__pkvm_cpu_set_vector),
	HANDLE_FUNC(__kvm_enable_ssbs),
	HANDLE_FUNC(__vgic_v3_init_lrs),
	HANDLE_FUNC(__vgic_v3_get_gic_config),
	HANDLE_FUNC(__pkvm_prot_finalize),

	HANDLE_FUNC(__pkvm_host_share_hyp),
	HANDLE_FUNC(__pkvm_host_unshare_hyp),
	HANDLE_FUNC(__pkvm_host_share_guest),
	HANDLE_FUNC(__pkvm_host_unshare_guest),
	HANDLE_FUNC(__pkvm_host_relax_perms_guest),
	HANDLE_FUNC(__pkvm_host_wrprotect_guest),
	HANDLE_FUNC(__pkvm_host_test_clear_young_guest),
	HANDLE_FUNC(__pkvm_host_mkyoung_guest),
	HANDLE_FUNC(__kvm_adjust_pc),
	HANDLE_FUNC(__kvm_vcpu_run),
	HANDLE_FUNC(__kvm_flush_vm_context),
	HANDLE_FUNC(__kvm_tlb_flush_vmid_ipa),
	HANDLE_FUNC(__kvm_tlb_flush_vmid_ipa_nsh),
	HANDLE_FUNC(__kvm_tlb_flush_vmid),
	HANDLE_FUNC(__kvm_tlb_flush_vmid_range),
	HANDLE_FUNC(__kvm_flush_cpu_context),
	HANDLE_FUNC(__kvm_timer_set_cntvoff),
	HANDLE_FUNC(__vgic_v3_save_vmcr_aprs),
	HANDLE_FUNC(__vgic_v3_restore_vmcr_aprs),
	HANDLE_FUNC(__pkvm_reserve_vm),
	HANDLE_FUNC(__pkvm_unreserve_vm),
	HANDLE_FUNC(__pkvm_init_vm),
	HANDLE_FUNC(__pkvm_init_vcpu),
	HANDLE_FUNC(__pkvm_teardown_vm),
	HANDLE_FUNC(__pkvm_vcpu_load),
	HANDLE_FUNC(__pkvm_vcpu_put),
	HANDLE_FUNC(__pkvm_tlb_flush_vmid),
};

static void handle___kvm_vcpu_run(struct kvm_cpu_context *host_ctxt)
{
	DECLARE_REG(struct kvm_vcpu *, host_vcpu, host_ctxt, 1);
	int ret;

	if (unlikely(is_protected_kvm_enabled())) {
		struct pkvm_hyp_vcpu *hyp_vcpu = pkvm_get_loaded_hyp_vcpu();

		/*
		 * KVM (and pKVM) doesn't support SME guests for now, and
		 * ensures that SME features aren't enabled in pstate when
		 * loading a vcpu. Therefore, if SME features enabled the host
		 * is misbehaving.
		 */
		if (unlikely(system_supports_sme() &amp;&amp; read_sysreg_s(SYS_SVCR))) {
			ret = -EINVAL;
			goto out;
		}

		if (!hyp_vcpu) {
			ret = -EINVAL;
			goto out;
		}

		flush_hyp_vcpu(hyp_vcpu);

		ret = __kvm_vcpu_run(&amp;hyp_vcpu-&gt;vcpu);

		sync_hyp_vcpu(hyp_vcpu);
	} else {
		struct kvm_vcpu *vcpu = kern_hyp_va(host_vcpu);

		/* The host is fully trusted, run its vCPU directly. */
		fpsimd_lazy_switch_to_guest(vcpu);
		ret = __kvm_vcpu_run(vcpu);
		fpsimd_lazy_switch_to_host(vcpu);
	}
out:
	cpu_reg(host_ctxt, 1) =  ret;
}
</code></pre>
<p><code>__kvm_vcpu_run</code>上下文切换前的准备，如果要切换到guest，则__sysreg_restore_state_nvhe(guest_ctxt);将guest的pc寄存器写elr寄存器，方便<code>__enter_guest</code> eret进入到guest代码执行。</p>
<p>当guest陷入异常后，<code>__enter_exit</code>只是ret返回当前代码仍然在el2级别，只有在退出<code>__kvm_vcpu_run</code> 前，调用<code>__sysreg_restore_state_nvhe(host_ctxt)</code>，将host 的pc寄存器写入到elr寄存，方便后续返回到host el1状态，这一点是nvhe独有的。</p>
<p>当<code>__kvm_vcpu_run</code>层层返回，直到<code>__host_exit</code>里的<code>handle_trap</code>返回，继续执行到eret,最终从__host_exit返回到host el1，页就是<code>kvm_call_hyp_ret</code>展开后hvc调用后的那个指令，宏观上可以认为是kvm_call_hyp_ret返回后，从el2回到host el1。</p>
<h2 id="在hyp里切换host和guest状态"><a class="header" href="#在hyp里切换host和guest状态">在hyp里切换host和guest状态</a></h2>
<pre><code class="language-c">/* Switch to the guest for legacy non-VHE systems */
int __kvm_vcpu_run(struct kvm_vcpu *vcpu)
{
	struct kvm_cpu_context *host_ctxt;
	struct kvm_cpu_context *guest_ctxt;
	struct kvm_s2_mmu *mmu;
	bool pmu_switch_needed;
	u64 exit_code;

	host_ctxt = host_data_ptr(host_ctxt);
	host_ctxt-&gt;__hyp_running_vcpu = vcpu;
	guest_ctxt = &amp;vcpu-&gt;arch.ctxt;

	__sysreg_save_state_nvhe(host_ctxt);


	/*
	 * We must restore the 32-bit state before the sysregs, thanks
	 * to erratum #852523 (Cortex-A57) or #853709 (Cortex-A72).
	 *
	 * Also, and in order to be able to deal with erratum #1319537 (A57)
	 * and #1319367 (A72), we must ensure that all VM-related sysreg are
	 * restored before we enable S2 translation.
	 */
	__sysreg32_restore_state(vcpu);
	__sysreg_restore_state_nvhe(guest_ctxt);

	mmu = kern_hyp_va(vcpu-&gt;arch.hw_mmu);
	__load_stage2(mmu, kern_hyp_va(mmu-&gt;arch));
	__activate_traps(vcpu);

	do {
		/* Jump in the fire! */
		exit_code = __guest_enter(vcpu);

		/* And we're baaack! */
	} while (fixup_guest_exit(vcpu, &amp;exit_code));

	__sysreg_save_state_nvhe(guest_ctxt);

	/*
	 * Same thing as before the guest run: we're about to switch
	 * the MMU context, so let's make sure we don't have any
	 * ongoing EL1&amp;0 translations.
	 */

	__deactivate_traps(vcpu);
	__load_host_stage2();

	__sysreg_restore_state_nvhe(host_ctxt);

	return exit_code;
}
</code></pre>
<h2 id="在hyp返回前恢复elr"><a class="header" href="#在hyp返回前恢复elr">在hyp返回前恢复ELR</a></h2>
<p><code>__sysreg_restore_state_nvhe</code>将ctxt里记录的PC寄存器写入ELR寄存，将pstate写入SPSR寄存器，eret就回到了host el1。</p>
<pre><code class="language-c">void __sysreg_restore_state_nvhe(struct kvm_cpu_context *ctxt)
{
	u64 midr = ctxt_midr_el1(ctxt);

	__sysreg_restore_el1_state(ctxt, midr, ctxt_sys_reg(ctxt, MPIDR_EL1));
	__sysreg_restore_common_state(ctxt);
	__sysreg_restore_user_state(ctxt);
	__sysreg_restore_el2_return_state(ctxt);
}


static inline void __sysreg_restore_el2_return_state(struct kvm_cpu_context *ctxt)
{
	u64 pstate = to_hw_pstate(ctxt);
	u64 mode = pstate &amp; PSR_AA32_MODE_MASK;
	u64 vdisr;

	/*
	 * Safety check to ensure we're setting the CPU up to enter the guest
	 * in a less privileged mode.
	 *
	 * If we are attempting a return to EL2 or higher in AArch64 state,
	 * program SPSR_EL2 with M=EL2h and the IL bit set which ensures that
	 * we'll take an illegal exception state exception immediately after
	 * the ERET to the guest.  Attempts to return to AArch32 Hyp will
	 * result in an illegal exception return because EL2's execution state
	 * is determined by SCR_EL3.RW.
	 */
	if (!(mode &amp; PSR_MODE32_BIT) &amp;&amp; mode &gt;= PSR_MODE_EL2t)
		pstate = PSR_MODE_EL2h | PSR_IL_BIT;

	write_sysreg_el2(ctxt-&gt;regs.pc,			SYS_ELR);
	write_sysreg_el2(pstate,			SYS_SPSR);

	if (!cpus_have_final_cap(ARM64_HAS_RAS_EXTN))
		return;

	if (!vserror_state_is_nested(ctxt_to_vcpu(ctxt)))
		vdisr = ctxt_sys_reg(ctxt, DISR_EL1);
	else if (ctxt_has_ras(ctxt))
		vdisr = ctxt_sys_reg(ctxt, VDISR_EL2);
	else
		vdisr = 0;

	write_sysreg_s(vdisr, SYS_VDISR_EL2);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="spdx"><a class="header" href="#spdx">SPDX</a></h1>
<p>SPDX(Software Package Data Exchange)是一种文件格式，用于记录有关分发给定计算机软件的软件许可证的信息。SPDX 是由 SPDX 工作组编写的，该工作组代表了 20 多个不同的组织，由 Linux 基金会所支持。</p>
<p>简单的说，就是简化授权说明。</p>
<h2 id="reuse"><a class="header" href="#reuse">reuse</a></h2>
<p>该工具用于在文件头添加SPDX格式的版权与license。</p>
<p>官方用例，init初始reuse，download下载license，addheader添加license到文件头，<code>addheader</code>会根据文件类型自动添加注释,最后reuse lint检测。</p>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://download.fsfe.org/videos/reuse/screencasts/reuse-tool.gif">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">官方用例</div>

</center>
可用开源协议：<https: spdx.org="" licenses="" /> ，选一个[GPL-3.0-or-later](https://spdx.org/licenses/GPL-3.0-or-later.html)。
<pre><code class="language-shell">#新建项目
git clone -b noncompliant https://github.com/fsfe/reuse-example.git

#初始化,生成文件`.reuse/dep5`
pip3 install reuse
cd reuse-example &amp;&amp; reuse init 

#下载协议放到LICENSES/GPL-3.0-or-later.txt，reuse download --all 下载所有
reuse download GPL-3.0-or-later CC0-1.0

#添加所有文件，不想添加的文件加入.gitignore
reuse addheader --copyright="Jane Doe &lt;jane@example.com&gt;" --license="GPL-3.0-or-later" src/main.c Makefile README.md

reuse addheader --copyright="Jane Doe &lt;jane@example.com&gt;" --license="GPL-3.0-or-later" --force-dot-license img/cat.jpg img/dog.jpg

reuse addheader --copyright="Jane Doe &lt;jane@example.com&gt;" --license="CC0-1.0" .gitignore

#检测合规，会列举未授权的文件，最终要看到`Congratulations!`才行。
reuse lint
</code></pre>
<h2 id="开源协议分类"><a class="header" href="#开源协议分类">开源协议分类</a></h2>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://picd.zhimg.com/80/253a7b1819e2af555ed0a7e0f11a0b59_720w.webp?source=1940ef5c">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">开源协议分类</div>

</center>
<p>参考：https://reuse.software/tutorial/</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lvgl"><a class="header" href="#lvgl">LVGL</a></h1>
<p>在linux下使用lvgl编写gui程序，使用lv_port_linux编译出动态库，简化在linux的开发环境流程。</p>
<h2 id="制作debian包"><a class="header" href="#制作debian包">制作Debian包</a></h2>
<h3 id="1安装环境"><a class="header" href="#1安装环境">1.安装环境</a></h3>
<pre><code class="language-shell">sudo apt update
sudo apt install pkg-config
sudo apt install libwayland-dev libxkbcommon-dev libwayland-bin wayland-protocols libdrm-dev
</code></pre>
<h3 id="2修改lv_port_linux的一些默认配置"><a class="header" href="#2修改lv_port_linux的一些默认配置">2.修改lv_port_linux的一些默认配置</a></h3>
<p>CMakeLists.txt,，方便编译动态库。</p>
<pre><code class="language-shell"> # Link LVGL with external dependencies - Modern CMake/CMP0079 allows this
-target_link_libraries(lvgl PUBLIC ${PKG_CONFIG_LIB} m pthread)
+target_link_libraries(lvgl PUBLIC ${PKG_CONFIG_LIB} m pthread rt)
</code></pre>
<p>编译开关</p>
<p>LV_USE_PRIVATE_API，打包dev开发包的时候，私有头文件也要包含，否则会找不到头文件。</p>
<p>LV_USE_WAYLAND，启用wayland后端</p>
<p>LV_WAYLAND_WINDOW_DECORATIONS，开启这个，可以使得wayland窗口管理器管理app，否则app无法拖动。</p>
<p>LV_USE_LINUX_DRM，使用DRM后端</p>
<pre><code class="language-shell"> /** Include `lvgl_private.h` in `lvgl.h` to access internal data and functions by default */
 #ifndef LV_USE_PRIVATE_API
-    #define LV_USE_PRIVATE_API  0
+    #define LV_USE_PRIVATE_API  1
 #endif

 
 /** Use Wayland to open a window and handle input on Linux or BSD desktops */
-#define LV_USE_WAYLAND          0
+#define LV_USE_WAYLAND          1
 #if LV_USE_WAYLAND

/**&lt; When LV_WAYLAND_USE_DMABUF is disabled, only LV_DISPLAY_RENDER_MODE_PARTIAL is supported*/
-    #define LV_WAYLAND_WINDOW_DECORATIONS   0    /**&lt; Draw client side window decorations only necessary on Mutter/GNOME. Not supported using DMABUF*/
+    #define LV_WAYLAND_WINDOW_DECORATIONS   1    /**&lt; Draw client side window decorations only necessary on Mutter/GNOME. Not supported using DMABUF*/
     #define LV_WAYLAND_WL_SHELL             0    /**&lt; Use the legacy wl_shell protocol instead of the default XDG shell*/
 #endif

 /** Driver for /dev/dri/card */
-#define LV_USE_LINUX_DRM        0
+#define LV_USE_LINUX_DRM        1
 
 #if LV_USE_LINUX_DRM
</code></pre>
<p>3.创建Debian构建文件</p>
<pre><code class="language-shell">cd lv_port_linux &amp;&amp; mkdir -p debian &amp;&amp; cd debian
</code></pre>
<p>添加control文件</p>
<pre><code class="language-shell">Source: lvgl
Section: libs
Priority: optional
Maintainer: LVGL Maintainer &lt;maintainer@example.com&gt;
Build-Depends: debhelper-compat (= 13), cmake, pkg-config, libwayland-dev, wayland-protocols, libxkbcommon-dev, libdrm-dev
Standards-Version: 4.6.2
Homepage: https://lvgl.io

Package: liblvgl9
Architecture: any
Depends: ${shlibs:Depends}, ${misc:Depends}
Description: LittlevGL runtime library
 LVGL graphics library runtime shared objects.

Package: liblvgl-dev
Architecture: any
Depends: liblvgl9 (= ${binary:Version}), ${misc:Depends}
Description: LittlevGL development files (headers, pkg-config)
 Development headers, shared libs and pkg-config for LVGL.
</code></pre>
<p>添加rules</p>
<pre><code class="language-shell">#!/usr/bin/make -f
export DH_VERBOSE=1

%:
	dh $@ --buildsystem=cmake

#编译动态库
override_dh_auto_configure:
	# 可选：若需从 lv_conf.defaults 生成 lv_conf.h
	# python3 lvgl/scripts/generate_lv_conf.py .
	bash ./scripts/gen_wl_protocols.sh ./protocols
	# 解决 Wayland 协议生成代码中符号可见性为 hidden 导致 DSO 链接失败
	sed -i 's/^#define WL_PRIVATE __attribute__ ((visibility("hidden")))/#define WL_PRIVATE/' ./protocols/wayland_xdg_shell.c || true
	dh_auto_configure --builddirectory=build -- \
	  -DCMAKE_INSTALL_PREFIX=/usr \
	  -DBUILD_SHARED_LIBS=ON \
	  -DLIB_INSTALL_DIR=lib/${DEB_HOST_MULTIARCH} \
	  -DCMAKE_C_FLAGS='-DWL_PRIVATE=' \
	  -DCMAKE_EXE_LINKER_FLAGS='-Wl,--export-dynamic' \
	  -DLV_BUILD_EXAMPLES=ON \
	  -DLV_BUILD_DEMOS=ON

override_dh_auto_build:
	# Wayland scanner generates hidden symbols; neutralize before linking
	sed -i 's/^#define WL_PRIVATE __attribute__ ((visibility("hidden")))/#define WL_PRIVATE/' build/protocols/wayland_xdg_shell.c || true
	dh_auto_build --builddirectory=build -- -j$(nproc)

override_dh_auto_install:
	dh_auto_install --builddirectory=build --destdir=$(CURDIR)/debian/tmp
	# 等同于：DESTDIR=$(CURDIR)/debian/tmp cmake --install build

override_dh_auto_clean:
	# 保持与 out-of-source 一致的清理
	dh_auto_clean --builddirectory=build || true

override_dh_auto_test:
</code></pre>
<p>添加install文件</p>
<p>liblvgl9.install</p>
<pre><code>usr/lib/*/liblvgl.so.*
usr/lib/*/liblvgl_demos.so.*
usr/lib/*/liblvgl_examples.so.*
usr/lib/*/liblvgl_thorvg.so.*
</code></pre>
<p>liblvgl-dev.install</p>
<pre><code class="language-shell">usr/include/lvgl/
usr/share/pkgconfig/lvgl.pc
usr/lib/*/liblvgl.so
usr/lib/*/liblvgl_demos.so
usr/lib/*/liblvgl_examples.so
usr/lib/*/liblvgl_thorvg.so
usr/lib/liblvgl_linux.a
</code></pre>
<h4 id="liblvgl_linuxa为什么不改成动态库"><a class="header" href="#liblvgl_linuxa为什么不改成动态库">liblvgl_linux.a为什么不改成动态库？</a></h4>
<ul>
<li>
<p>目标在 CMake 中被明确声明为 STATIC：项目把平台封装/后端适配层做成了内部静态库（add_library(lvgl_linux STATIC …)），默认不会随 -DBUILD_SHARED_LIBS=ON 变成动态库。要修改，则会大量的地方修改适配。</p>
</li>
<li>
<p>仅供内部链接、非稳定 ABI：lvgl_linux 属于本仓库的“Linux 适配层”，主要被可执行程序或 liblvgl.so 内部使用，没承诺对外 ABI 稳定，不适合作为独立 .so 提供。</p>
</li>
<li>
<p>Wayland 生成代码的符号可见性问题：wayland-scanner 生成的 wayland_xdg_shell.c 使用 WL_PRIVATE 把接口标记为隐藏，直接做成 .so 会出现“hidden symbol is referenced by DSO”的链接问题，需要额外处理（我们在打包时通过 -DWL_PRIVATE= 和 –export-dynamic 才解决）。</p>
</li>
<li>
<p>避免循环依赖与依赖膨胀：如果把 lvgl_linux 做成共享库，很容易与 liblvgl.so、liblvgl_examples.so、liblvgl_demos.so 形成相互引用，导致复杂的运行时依赖和 shlibdeps 噪音。当前方案是把对外 .so 限定在核心和演示库，其它平台层静态链接使用。</p>
</li>
</ul>
<h4 id="liblvglso-和-liblvgl_linuxa-的区别"><a class="header" href="#liblvglso-和-liblvgl_linuxa-的区别">liblvgl.so 和 liblvgl_linux.a 的区别?</a></h4>
<h5 id="liblvglso--lvgl-核心库"><a class="header" href="#liblvglso--lvgl-核心库">liblvgl.so- LVGL 核心库</a></h5>
<p>主要功能：</p>
<ul>
<li>LVGL 核心功能：包含所有 LVGL 的核心 API 和功能</li>
<li>对象系统：lv_obj_* 系列函数，如 lv_obj_create, lv_obj_add_flag 等</li>
<li>绘图系统：lv_draw_* 系列函数，如 lv_draw_triangle, lv_draw_triangle_dsc_init 等</li>
<li>字体系统：lv_font_* 系列函数和字体数据，如 lv_font_montserrat_24 等</li>
<li>显示驱动接口：lv_linux_drm_create, lv_wayland_window_create 等 Linux 特定驱动函数</li>
<li>输入设备接口：lv_indev_* 系列函数</li>
<li>组管理：lv_group_* 系列函数</li>
</ul>
<h5 id="liblvgl_linuxa---linux-平台特定库"><a class="header" href="#liblvgl_linuxa---linux-平台特定库">liblvgl_linux.a - Linux 平台特定库</a></h5>
<p>主要功能：</p>
<ul>
<li>驱动后端管理：driver_backends_* 系列函数</li>
<li>后端初始化：backend_init_* 系列函数</li>
<li>Wayland 协议接口：包含 Wayland XDG 协议的接口定义</li>
<li>平台特定实现：Linux 特定的驱动初始化和运行循环</li>
</ul>
<h3 id="3构建deb包"><a class="header" href="#3构建deb包">3.构建deb包</a></h3>
<pre><code class="language-shell">cd lv_port_linux/
sudo apt build-dep .
dpkg-buildpackage -us -uc -tc  -b
</code></pre>
<p>生成三个包：</p>
<p>liblvgl9_9.3.0-1_amd64.deb，带动态库。</p>
<p>liblvgl-dev_9.3.0-1_amd64.deb，带头文件和liblvgl_linux.a，里面的动态库链接到liblvgl9的动态库。</p>
<p>liblvgl9-dbgsym_9.3.0-1_amd64.deb，带动态库调试符号。</p>
<p>理论上来说，开发接口是固定的，因此liblvgl-dev名字中是不带版本9，而提供的动态库liblvgl9则需要带版本9，最新liblvgl-dev通过对liblvgl9的依赖，保证liblvgl-dev可以使用新的库。</p>
<h3 id="4编译测试"><a class="header" href="#4编译测试">4.编译测试</a></h3>
<p>先安装开发环境</p>
<pre><code class="language-shell">sudo dpkg -i ../liblvgl9_9.3.0-1_amd64.deb  ../liblvgl-dev_9.3.0-1_amd64.deb
</code></pre>
<p>进入example编译例子</p>
<pre><code class="language-shell">cd lv_port_linux/example/
cmake -B build -S .
make -C build -j
#运行例子
./bin/main
</code></pre>
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="linux/pic/lvgl.gif">
    <br>
    
<div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">example例子</div>

</center>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-zig"><a href="#build-zig" class="header">Build Zig</a></h1>
<h2 id="源码编译zig"><a class="header" href="#源码编译zig">源码编译zig</a></h2>
<h3 id="添加llvm18的源"><a class="header" href="#添加llvm18的源">添加llvm18的源</a></h3>
<p>zig要求这个版本</p>
<pre><code class="language-shell"># uos v20
deb http://apt.llvm.org/buster/ llvm-toolchain-buster main
deb-src http://apt.llvm.org/buster/ llvm-toolchain-buster main
# 18 
deb http://apt.llvm.org/buster/ llvm-toolchain-buster-18 main
deb-src http://apt.llvm.org/buster/ llvm-toolchain-buster-18 main
# 19 
deb http://apt.llvm.org/buster/ llvm-toolchain-buster-19 main
deb-src http://apt.llvm.org/buster/ llvm-toolchain-buster-19 main

# deepin v23
deb http://apt.llvm.org/bookworm/ llvm-toolchain-bookworm main
deb-src http://apt.llvm.org/bookworm/ llvm-toolchain-bookworm main
# 18 
deb http://apt.llvm.org/bookworm/ llvm-toolchain-bookworm-18 main
deb-src http://apt.llvm.org/bookworm/ llvm-toolchain-bookworm-18 main
# 19 
deb http://apt.llvm.org/bookworm/ llvm-toolchain-bookworm-19 main
deb-src http://apt.llvm.org/bookworm/ llvm-toolchain-bookworm-19 main
</code></pre>
<pre><code class="language-shell">https://apt.llvm.org/
wget -qO- https://apt.llvm.org/llvm-snapshot.gpg.key | sudo tee /etc/apt/trusted.gpg.d/apt.llvm.org.asc
</code></pre>
<blockquote>
<p>https://apt.llvm.org/</p>
</blockquote>
<h3 id="配置编译环境"><a class="header" href="#配置编译环境">配置编译环境</a></h3>
<pre><code class="language-shell">sudo apt install -y build-essential cmake clang-18 libclang-18-dev libclang-cpp18-dev llvm-18 llvm-18-dev lld-18 liblld-18-dev libpolly-18-dev libllvm18
</code></pre>
<pre><code class="language-shell">alias llvm-config=/lib/llvm-18/bin/llvm-config
llvm-config --cxxflags --ldflags --system-libs --libs core
</code></pre>
<blockquote>
<p>https://github.com/ziglang/zig/issues/419</p>
</blockquote>
<h3 id="下载zig源码编译"><a class="header" href="#下载zig源码编译">下载zig源码编译</a></h3>
<p>在build目录构建，方便删除</p>
<pre><code class="language-shell">git clone https://mirror.ghproxy.com/https://github.com/ziglang/zig.git
cd zig
mkdir build
cd build
cmake ..  -DCMAKE_PREFIX_PATH=/usr/lib/llvm-18  -DZIG_STATIC_LLVM=ON
make
</code></pre>
<blockquote>
<p>https://github.com/ziglang/zig/wiki/Building-Zig-From-Source</p>
</blockquote>
<p>以上步骤为了验证是否能正常打包。</p>
<h2 id="构建debian包"><a class="header" href="#构建debian包">构建debian包</a></h2>
<h3 id="准备环境"><a class="header" href="#准备环境">准备环境</a></h3>
<pre><code class="language-shell">sudo apt install dh-make
</code></pre>
<h3 id="制作debian文件"><a class="header" href="#制作debian文件">制作debian文件</a></h3>
<p>生成debian目录</p>
<pre><code class="language-shell">#移除编译build目录，否则--createorig参数创建源码包会包含这些
rm -rf build

#获取最新tag信息,用于作为debian版本
ver=$(git describe --tags --abbrev=0)
git checkout $ver
dh_make  -p zig_$ver  -s -y --createorig
rm -f debian/*.ex
</code></pre>
<p>编辑debian内的文件,关键是添加Build-Depends，方便<code>apt build-dep .</code>自动下载打包依赖。
如果有修改，需要<code>dch -i</code>命令添加changelog</p>
<p>debian/control文件内容。</p>
<pre><code class="language-shell">Source: zig
Section: devel
Priority: optional
Maintainer: errorcode7 &lt;errorcode7@qq.com&gt;
Build-Depends: debhelper (&gt;= 11),dh-make,dpkg-dev,build-essential,cmake,clang-18,libclang-18-dev,libclang-cpp18-dev,llvm-18,llvm-18-dev,lld-18,liblld-18-dev,libpolly-18-dev,libllvm18
Standards-Version: 4.1.3
Homepage: https://ziglang.org/
Vcs-Git: https://github.com/ziglang/zig

Package: zig
Architecture: any
Depends: ${shlibs:Depends}, ${misc:Depends}
Description: Zig is a general-purpose programming language and toolchain for maintaining robust, optimal and reusable software.
</code></pre>
<blockquote>
<p>https://github.com/errorcode7/zig/tree/master/debian</p>
</blockquote>
<p>dpkg-buildpackage打包</p>
<pre><code class="language-shell"># 因为有Cmake文件，直接构建即可
rm -rf  .zig-cache/
dpkg-buildpackage -uc -us -tc 
</code></pre>
<p>可能会提示gpg签名失败，不要紧，已经打包好了。</p>
<pre><code class="language-shell">dpkg -c ../zig_*.deb
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
